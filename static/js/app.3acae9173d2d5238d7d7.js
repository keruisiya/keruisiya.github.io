webpackJsonp([1],{0:function(e,t){},"991W":function(e,t){},CCyo:function(e,t){e.exports={bloglists:[{Id:1,title:"html+css内容梳理",content:"html+css.md",category:"html+css",describe:"dfasdfsd",date:"2020-3-18"},{Id:2,title:"js梳理1",content:"js上.md",category:"js",describe:"none",date:"2020-3-25"},{Id:3,title:"js梳理2",content:"js下.md",category:"js",describe:"none",date:"2020-3-30"},{Id:4,title:"dapp搭建",content:"dapp.md",category:"node",describe:"none",date:"2020-4-17"}]}},Df8s:function(e,t){e.exports="<p>一共三个大案例： 云道、京东、学成在线 疑问：通栏居中为什么要用一个盒子嵌套包裹呀； 因为又要通栏又要居中呀</p> <p>1、html常见标签（day1） 2、表单中label标签，label中的for 属性 用于和表单中的id 绑定 （****）重置按钮和提交按钮 在form中才可以用；</p> <pre><code>表格（设置三参为0  border，cellspacing cellpadding）、介绍合并单元格</code></pre><p>3、行内式；（偶尔使用）、内部样式表、外部样式表 行内权重高，但是只能控制单个标签</p> <p>4、标签命名规范：web前端开发规范手册.doc ---------- <a href=https://www.cnblogs.com/xiaonian0327/p/7735799.html>https://www.cnblogs.com/xiaonian0327/p/7735799.html</a> 常用查询文档： w3c、MDN 拔网页小工具：day12中</p> <p>5、css三大特性： 层叠性： 后来的css代码中样式 会覆盖前面的； 样式不冲突 ，不会层叠；</p> <pre><code>    继承性：子标签会继承父标签的 某些样式；\n        如： color  text-  font-  line- 都是可以继承的；\n        但是高 是不继承的；margin和padding是不会继承的（显而易见好吧）\n\n        恰当的利用继承性可以简化代码，降低css样式的复杂性；\n\n    优先级：\n         id选择&gt; 类选择器&gt; 标签选择器；\n\n         标签权重  0，0，0，1；\n         类选择器  0，0，1，0；\n         id选择器  0，1，0，0；\n         行内样式  1，0，0，0；\n         ！important 无穷大；\n\n        * 和继承   0，0，0，0  权重最小；\n    记住的： 父元素的权重再大  继承过后  子元素的权重也还是0；\n\n    权重是可以叠加的：(子代选择器 交集选择器都会叠加)\n        div ul li  0，0，0，3\n        .nav ul li 0，0，1，2\n        a:hover 0,0,1,1;（********）\n\n\n            1、权重相同 ，则就近原则；\n            2、权重会叠加\n            3、记住权重是不进位的   0005+0005 ！= 0010 的  而是0，0，0，10；</code></pre><p>a:hover .mask （空格 表示后代选择器 表示 a里面的mask显示出来）（<strong>*****</strong>伪类选择器 的这种形式的理解）</p> <p>6、标签的分类： 块级元素（独自站一行 可以设置宽高 对齐属性） 如：h1 p div ul ol li</p> <pre><code>             特点：默认的宽是100%\n                    可以容纳内联元素和其他块元素\n\n            行内元素\n                     如 a strong em b i del s span等\n\n              特点：不占独立的区域； 仅仅依靠自身的字体大小和图片支撑结构\n                    不可以设置宽度 高度 对齐属性（text-align 因为宽没用了 也没用了）；\n                    默认的宽度就是他自身的内容的宽度；\n                    行内元素只能容纳文本或者其他行内元素（a特殊）\n\n            行内块元素（inline-block）\n                如： img input  td\n\n                特点： 和相邻的行内元素（行内块）在一行上 但是之间会有白色空隙；\n                        默认宽度就是它本身内容宽度\n                        高度行高 外边距和内边距都可以控制；</code></pre><p>(<strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong>) 行内块元素和内容有关系的； 如果没有内容 又没有设置宽或者高 就是空的； 行内元素和行内块元素 的宽度 不是设置的默认100%了 而是内容多少就是多少，内容为空就是0</p> <p> a标签 span行内元素 也是不会被图片撑开 ； 宽度是 图片的宽度， 但是高度还是自己的</p> <p>行内元素与块级元素的区别之一就是 对于行内元素来说margin只 有margin-left和margin-right有效，padding只有padding-left和padding-right有效</p> <p> (<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>)</p> <pre><code>            一、块级元素 内部文字水平居中\n                  行内元素和行内块元素可以看成是文本  可以使用text-align居中对齐；\n\n            二、 虽然块级元素内部可以放 块级元素和行内元素以及行内块元素；\n           但是 对于p和 h1标签而言  文字才能组成段落  ，所以在p标签和 h1 标签中也一般不装块级元素\n\n\n           三、虽然行内元素只能容纳文本或者其他行内元素\n             但是a特殊  是可以放块级元素的\n             （a放块级元素的时候是不是将自己变成行内块元素或者是块级元素）</code></pre><p>7、样式连写：字体font 背景background 文本（color，text-decoration，text-align、line-height） 背景位置介绍： background-position : x，y （可以用方位名词 center top left 也可以用px 混合用也可以） （精灵图用的） /<em>1. positon后面可以跟方位名词 他们之间可以没有上下顺序</em>/ /<em>2. position 如果只写一个方位名词，另外一个默认是居中的</em>/ /*3. position 后面也可以跟 值px 但是 必须有顺序 x 在前面 y 后面 不能颠倒 */ background-position : 10px，center 是可以的 left top 是默认值；</p> <p>（<strong>***</strong>） 位置中的center 是把背景图放在盒子的中线上；</p> <pre><code>      如果图比盒子大的话 ，图会超出盒子 的  也就是图的中心部分还是在盒子的中心的；\n\nfont的连写： font：12px/1.5 （表示的是行高 1.5* font-size）\n\n注意：background-attachment\n\n行高是用在单行文本中的</code></pre><p>8、 经常混淆的几个样式： 背景透明：rbga() 用在background中 盒子阴影 box-shadow 盒子透明 opacity 盒子包括盒子的内容都透明</p> <pre><code>    透明设置方式背景：background： rgba(0,0,0,0.3 )\n\n    盒子阴影（css3）box-shadow：水平阴影  垂直阴影  模糊距离  阴影尺寸（就是影子的大小）  颜色   内外阴影（默认外阴影）\n\n    盒子透明 opacity: 0.2;  /*盒子半透明  字也透明了 盒子也透明了*/</code></pre><p>盒子模型： 9、input中的边框也可以使用border；</p> <p>10、盒子居中；满足条件： 必须是块级元素；盒子必须指定了width才可以； margin ：0 auto （设置左右自动充满） 块级元素单行文本垂直居中 -------- line-height=height 定位的盒子居中对齐</p> <p>11、margin的两种坍塌现象；-----子元素带着父元素垂直方向跑； 现象描述： 对于两个嵌套关系的块元素， 如果父元素没有上内边距 和边框 则父元素的 上外边距会与子元素的上外边距发生合并 ，合并后的外边距为两者中的较大者，即使父元素 的上外边距为0，也会发生合并。</p> <p>12、 添加padding会撑开带有width和height的盒子； （<strong>****</strong>）没有设置宽高的不会撑开</p> <pre><code>如果一个子盒子没有给定宽度/高度，就会用其父类的属性，这时padding不会影响子盒子的大小(会自适应调节width)</code></pre><p>浮动和定位： 13 浮动----最早是用来实现文字环绕图片的；现在目的就是为了让多个块级元素在同一行上显示 （同一行上显示以前用inner-block做的， 但是它实现不了 靠页面右边显示。还有一个是inner-block 是有缝隙的）</p> <p>14、浮动特性： 浮动式脱离文档流 是不占位置的；会影响后面的标准流 因为浮动是在原有位置基础上 浮动的( 三个div 中间一个不设置float：left 第三个不是接在第一个div后面的)</p> <p>（<strong>****</strong>） 浮动并不是完全意义上的脱标（文字不会被盖住 还有图片也是）</p> <p>15、清除浮动：---清除浮动的本质就是： 为了解决父级元素因为子级浮动而引起内部高度为0 的问题；</p> <pre><code>四种方法：伪元素清除浮动</code></pre><p>16、定位的主要属性 就是定位模式（static（默认） relative absolute fixed）和边偏移 top left...；</p> <p>17、静态定位static 唯一的用处就是取消定位</p> <p>18、left: % 的时候是父元素的盒子宽度的大小；（就是说 width+padding的后的值） （<strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong>） 定位中left的值和right的值同时出现的时候 以 left和top为准 这个和css的层叠性没关系 也就是和先后设置没关系</p> <pre><code>  同时设置margin-left和margin-right也是  以left为准</code></pre><p>19、相对定位：根据自己的左上角进行定位，相对定位 原先的盒子位置依旧是保留的，会是压住标准流中的元素的（<strong>***</strong>）</p> <p>20、绝对定位是将元素依据最近的已经定位的 父元素（祖先）进行定位，是脱离标准文档流， 不占位置的 -----叫做完全脱标；</p> <p>21、定位的盒子居中对齐： （设置relative的盒子基本不受影响，一般父盒子会有relative 也会有margin：0 auto） ps： 加了浮动和定位（不包括relative） margin：x auto 就失效了（<strong><strong><strong>**</strong></strong></strong>）</p> <pre><code>  position：absolute；\n  left：50%；\n  margin-left：-50%*weight；（盒子宽度的一半）\n\n   top:50%\n   margin-top:-50%*height</code></pre><p>22、固定定位： 父元素加不加position top和left值都是相对浏览器页面的；</p> <p>23、z-index：（叠放次序） 表示的是z轴 ；-----改变叠放次序 -----------只有定位（relative，absolute，fixed都有）的盒子才有z-index ----浮动 静态定位都是没有z-index的； -----------z-index取值相同，后来者居上；</p> <p> 如果没有设置z-index 相同的 就后来者居上覆盖（但是并不是说它的z-index 依次变大）</p> <p>24、显示与隐藏：（三种 j visibility overflow） display：none 隐藏 block就是显示 隐藏之后是不保留位置的（<strong><strong>****</strong></strong>）</p> <pre><code>   opacity隐藏保留位置（但是h5c3中用了 position：就可以达到不占位置了）\n\n（了解）\n  visibility:visible hidden (inherid 是默认的  )\n        隐藏后是保留位置的；\n\n  overflow; 溢出隐藏；</code></pre><p>25、鼠标拖拽 轮廓和防止拖拽 不是只有a才可以设置cursor p img div 都可以 /<em>cursor: pointer; 让我们的鼠标样式变成小手</em>/ /<em>cursor: text; 让我们的鼠标样式变成选择 I</em>/ cursor: default; /* 让我们的鼠标样式小白<em>/ cursor: move; /*鼠标变成十字架样子</em>/</p> <p> 轮廓 outline: ---------一般都是结合表单和表单域使用 outline: none; /<em>取消轮廓线的做法</em>/ /<em>取消蓝色边框</em>/ 或者用outline：0</p> <p> 防止拖拽 防止它影响布局 resize: none; /<em>防止拖拽</em>/</p> <p>26、div直接装一个图片也会出现一条缝隙问题； -------div没设置 图片的height 高度；</p> <p> 图片和文字等inline元素默认是和父级元素的baseline基线对齐的，div不设置高度的时候 视其内容撑开盒子；所以导致这个问题 而baseline又和父级底边有一定距离（这个距离和 font-size，font-family 相关，不一定是 5px）</p> <p> 所以设置盒子div 的 font-size: 0;或者 line-height: 0; 也是可以的 还有设置img为block</p> <p>27、溢出文字隐藏 三个样式； white-space: nowrap; /<em>1.强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行</em>/ overflow: hidden; /* 2. 超出的部分 隐藏<em>/ text-overflow: ellipsis; /</em> 3. 溢出的部分用省略号替代*/</p> <pre><code>div等容器文字只会单行显示</code></pre><p>28、精灵图---一张大图 --操作background-position ： background: url(images/index.png) no-repeat -2px -184px;</p> <pre><code>不好做的那个精灵图 在 day12 中的携程案例中</code></pre><p>29、滑动门----根据内容 框适当变大 也是利用了背景图片：（父子都设置背景）</p> <pre><code>&lt;a href=&quot;#&quot;&gt;\n    &lt;span&gt;首页&lt;/span&gt;\n&lt;/a&gt;\na 左边放左圆角  但是文字需要向右移动15px</code></pre><p> span 右边放右圆角 但是文字需要向左移动15px</p> <p>30、字体图标的使用 看上去是图片 其实是字体 （****可以设置font-size） 文字 以小图标的形式展示的； 一、下载字体图标 icomoon 德国的和 iconfont 中国的 -----自己下载的放到d盘下了 D:\\python\\icomoon</p> <p>下载： 先点左上角的icomoon app 在选择想要的图标 后点击 右下角的generate font 再找右下角的download 下载压缩包iconmoon；</p> <p>解压后 我们只需要font文件夹复制到项目中 其中的demo.html中是我们要去复制的  styles.css 里面有 @font-face {...}（下载的不同 这里也不同）</p> <p>二、字体图标的使用： 首先： @font-face {...} 复制这个内容到style中； 其次： 在下载的 文件夹中的demo文件中 粘贴 想要的图标 再： font-family申明字体；(必须要声明font-size中声明的字体)</p> <pre><code> 还有一种伪元素结合图标字体使用；（div::before { content: &quot;\\ea51&quot;;）</code></pre><p>三、添加自定义的图标： 点击 import icons（了解） 将svg图片导入到 icomoon网站上就可以转换了； svg不可以设置字体大小和颜色； 重新下载新的压缩包 新的图标 添加 解决；</p> <p>四、（<strong><strong><strong><strong>***</strong></strong></strong></strong>）追加新的图标；（又想下载新的图标了） 不能合并 得重新下载 将 selection.json （方便追加的）导入点击import-icons 再下载就可以</p> <pre><code>重新下载后 再更新index</code></pre><p>31、h5 新标签和 css选择器： 表单标签 </p><fieldset> 新增的表单 （type=url等）具有鉴定功能<p></p> <p> 选择器（ul:last-child 结构伪类， div[class] 属性选择器）</p> <p>32、伪元素：（::before 和:: end ） /<em>必须带一个属性 content 伪元素 其实这个 before 是个盒子</em>/ /* 这个盒子是行内的盒子 可以转换*/</p> <pre><code>before 和 after 都是在div的内部的inline-block；</code></pre><p>33、css3的盒子 量的时候包括边框 、会自适应调节 盒子内容（就是以前的width）</p> <p>34、过渡：加在 要让变化的元素身上； /<em>transition: width 0.5s ease 0s, height 0.3s; 多组属性用逗号分隔</em>/</p> <p>35、2d：移动、放缩、旋转 移动后： 原来的位置还占用 位移 缩放都是这样 移动后和缩放放大后的区域 和设置relative一样，不会打扰标准流的元素，只会叠盖；只有原有位置影响布局， translate（x，y） 只有x值 默认y为0； 50% 是走自己盒子宽度的一半</p> <pre><code>（****************************）\n    transform： translateX（-20px）；\n    transform： scale（0.8）\n\n    后面的会覆盖的\n\n    解决：\n    连写 就可以了；\n    transform： translateX（-20px）scale（0.8）  （//先移动 后缩放）</code></pre><p>36、scale和rotate 可以设置 transform-origin的 默认中新点缩放</p> <p>37、animation：动画名称 花费时间 运动曲线 何时开始 播放次数（n 或者 infinite） 是否反方向（alternate 反向 normal（直接回原点））; /*声明动画 关键帧 @keyframes 动画名称 { } */ @keyframes</p> <p>38、伸缩布局 ：flex；----默认 按列分 flex-direction: column 父元素设置 diplay:flex; 子元素设置分数份数 ， 有margin 先用总的扣掉 再分份数 当子元素 设置固定大小时，去掉固定的 剩下的 不固定（伸缩的）分；</p> <pre><code>父元素可以设置min-width</code></pre><p>39、background-size ：规定背景图片的大小； /<em>background-size: w h 规定背景图像的尺寸;</em>/ /<em>background-size: 100px 100px;</em>/ /<em>background-size: 100px; 如果只有一个值 后面一个值默认为 auto 等比例缩放</em>/ /<em>也可以设置百分比： <em>/ /</em>background-size: cover;</em>/ cover ：把背景图片尽可能放大；保证图片始终充满背景区域，（如有溢出部分则隐藏）</p> <pre><code>background-size: contain;     contain： 会自动调整缩放比例，保证图片始终完整显示在背景区域</code></pre><p> 多背景：background: url(images/2.jpg) no-repeat top left , url(images/3.jpg) no-repeat bottom right; 背景渐变：background: -webkit-linear-gradient(top, red 0%, green 50%, blue 100%);</p> <p>40、浏览器前缀 -webkit 为了让低版本浏览器支持（谷歌前缀）； -moz 让火狐支持 火狐前缀 -ms 让微软支持</p> <p>41、3d变化 transform: translateX();translateY()（这两个2d中也有）;translateZ(); translate3d(x,y,z) rotateX() 沿着x轴旋转； 2d旋转用的是 rotate（）、rotateZ()</p> <p>ps操作： 一、标尺；（ctrl+r 显示标尺）右击标尺 改成像素</p> <p> 二、吸管 ： 可以吸取颜色； 按住空格键可以移动 ； 测量宽高： 选中矩形 选框工具（可以测得宽高） 取消选中的 用ctrl+d 辅助线： 直接从标尺中拖拉出来 测量版心 他用了 用顶行的视图 里面有清除所有的辅助线：</p> <pre><code>切图工具：在切logo的时候用的 切片大小可以调节  再导出 点击 web所用格式：\n      存储的结果中  ：要选中 选中的切片（*****）\n\n删除切片： 用切片选择工具： 选中就删除；\n        或者用顶行的视图 ： 里面有清除切片  可以清除掉所有的切片；</code></pre><p>(如何看字体的大小 不会弄 ) 如何看一个字体的大小： 选中ps中的文本框：</p> <p> ps中的图层的操作 ： 删除了图中的几个小圆点</p> <p> 图层切图 这块不行</p> </fieldset>"},LvpP:function(e,t){},N6U1:function(e,t){},NHnr:function(e,t,o){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=o("7+uW"),r={render:function(){var e=this.$createElement,t=this._self._c||e;return t("div",{attrs:{id:"app"}},[t("router-view")],1)},staticRenderFns:[]};var s=o("VU/8")({name:"App"},r,!1,function(e){o("N6U1")},null,null).exports,a=o("/ocq"),i={render:function(){var e=this.$createElement;return(this._self._c||e)("div",{staticClass:"home"},[this._v("\n  博客的首页\n")])},staticRenderFns:[]};var c=o("VU/8")({name:"Home",data:function(){return{}}},i,!1,function(e){o("vV80")},"data-v-51bef7c0",null).exports,l={render:function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("header",[o("div",{attrs:{id:"hd_info"}},[o("div",{attrs:{id:"my_motto"}},[e._v(e._s(e.motto))]),e._v(" "),e._m(0),e._v(" "),o("div",{staticClass:"clear"})]),e._v(" "),o("div",{attrs:{id:"header"}},[o("p",{staticClass:"h_r_3"}),o("p",{staticClass:"h_r_2"}),o("p",{staticClass:"h_r_1"}),e._v(" "),o("div",{attrs:{id:"bloger"}},[o("h1",[e._v(e._s(e.bloger)+"小可爱的博客")])]),e._v(" "),o("p",{staticClass:"h_r_1"}),o("p",{staticClass:"h_r_2"}),o("p",{staticClass:"h_r_3"})]),e._v(" "),o("div",{attrs:{id:"nav_menu"}},[o("router-link",{attrs:{to:"/detail"}},[e._v("所有博客")]),e._v(" "),o("router-link",{attrs:{to:"/detail/add"}},[e._v("添加博客")]),e._v(" "),o("a",{attrs:{href:"#"}},[e._v("关于我")]),e._v(" "),o("a",{attrs:{href:"#"}},[e._v("找找看")])],1)])},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{attrs:{id:"login_area"}},[t("span",{attrs:{id:"span_userinfo"}},[this._v("["),t("a",{attrs:{href:"#"}},[this._v("登录")]),this._v("·"),t("a",{attrs:{href:"#"}},[this._v("注册")]),this._v("]")])])}]};var p=o("VU/8")({name:"detail-header",data:function(){return{motto:"多一些不为什么的坚持~",bloger:"crisiya824"}}},l,!1,function(e){o("RS5e")},"data-v-79a670e5",null).exports,d={render:function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("footer",[o("footer",[o("ul",{staticClass:"scroll-link",on:{click:e.toTop}},[e._m(0)]),e._v(" "),o("div",{staticClass:"footer-wrap"},[o("div",{staticClass:"w main-footer"},[o("div",{staticClass:"foot-top clearfix"},[e._m(1),e._v(" "),e._m(2),e._v(" "),o("div",{staticClass:"right follow"},[o("a",{staticClass:"concat",attrs:{href:"#"}},[e._v("Follow @ "+e._s(e.bloger))]),e._v(" "),o("ul",[o("li",{staticClass:"emial"},[e._v("邮箱: "+e._s(e.email))]),e._v(" "),o("li",{staticClass:"phone"},[e._v("电话: "+e._s(e.phone))])])])])])]),e._v(" "),o("div",{staticClass:"footer-bottom"},[o("div",{staticClass:"w xiamian-footer"},[o("div",{staticClass:"created-time left"},[o("a",{staticClass:"logo",attrs:{href:"/"}},[e._v("Storenvy")]),e._v("\n                  Design by © "+e._s(e.data)+".  All Rights Reserved."),o("br")]),e._v(" "),e._m(3)])])])])},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("li",[t("a",{attrs:{href:"#"}},[this._v("Back to TOP")])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"foot-list"},[t("ul",[t("li",[t("a",{attrs:{href:"#"}},[this._v("Blog Home")])]),this._v(" "),t("li",[t("a",{attrs:{href:"#"}},[this._v("Popular items")])]),this._v(" "),t("li",[t("a",{attrs:{href:"#"}},[this._v("Newest items")])]),this._v(" "),t("li",[t("a",{attrs:{href:"#"}},[this._v("Privated items")])])])])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"foot-list row2"},[t("ul",[t("li",[t("a",{attrs:{href:"#"}},[this._v("Github")])]),this._v(" "),t("li",[t("a",{attrs:{href:"#"}},[this._v("CSDN")])]),this._v(" "),t("li",[t("a",{attrs:{href:"#"}},[this._v("Tecent Cloud")])])])])},function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div",{staticClass:"bottom-center"},[o("a",{attrs:{href:"#"}},[e._v("Press Kit")]),e._v(" "),o("a",{attrs:{href:"#"}},[e._v("Terms")]),e._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[e._v("Privacy")]),e._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[e._v("Creative Rights")]),e._v(" ·\n                  "),o("a",{attrs:{href:"javascript:;"}},[e._v("Contact Us")]),e._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[e._v("Support@Storenvy.com")]),e._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[e._v("Support & FAQ")]),e._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[e._v("Copyright")])])}]};var u=o("VU/8")({name:"detail-footer",data:function(){return{bloger:"cirsiya824",data:"2020/5/18",email:"************@163.com",phone:"1**********"}},methods:{toTop:function(){}}},d,!1,function(e){o("tTbG")},"data-v-0415abcd",null).exports,g=o("nP45"),v={render:function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div",{staticClass:"blog-content"},[o("div",{staticClass:"header"},[e._m(0),e._v(" "),o("div",{staticClass:"search"},[o("input",{directives:[{name:"model",rawName:"v-model",value:e.search,expression:"search"}],attrs:{type:"text",placeholder:"搜索"},domProps:{value:e.search},on:{input:function(t){t.target.composing||(e.search=t.target.value)}}}),e._v(" "),o("button",[e._v("找找看")])])]),e._v(" "),o("div",{staticClass:"blog-exhition"},[e._l(e.filterBlogs,function(t){return o("div",{staticClass:"single-blog"},[o("router-link",{attrs:{to:"/detail/show/"+t.Id}},[o("div",{staticClass:"title"},[o("span",{staticClass:"create-type"},[e._v("原创")]),e._v(" "),o("h2",[e._v(e._s(e._f("to-uppercase")(t.title)))])]),e._v(" "),o("article",[e._v(e._s(t.describe))]),e._v(" "),o("div",{staticClass:"blog-describe"},[o("span",{staticClass:"create-date"},[e._v(e._s(t.date))]),e._v(" "),o("span",{staticClass:"blog-category"},[e._v("文章类型 : "+e._s(t.category))])])])],1)}),e._v(" "),o("div",{staticClass:"categories-exhibition"},[o("h3",[e._v("分类专栏")]),e._v(" "),o("div",{staticClass:"categories-content"},[o("ul",e._l(e.Categories,function(t){return o("li",{staticClass:"typeitem"},[o("a",{attrs:{href:"#"}},[o("span",{staticClass:"catename"},[e._v(e._s(t.catename))]),e._v(" "),o("span",{staticClass:"catenum"},[e._v(e._s(t.catenum)+"篇")]),e._v(" "),o("div",{staticClass:"clear"})])])}),0)])])],2)])},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"header-title"},[t("span",[t("a",{attrs:{href:"#"}},[this._v("我的博客")])]),this._v(" > "),t("span",[t("a",{attrs:{href:"#"}},[this._v("博客目录")])])])}]};var f=function(e){o("LvpP")},_={name:"Detail",data:function(){return{}},components:{DetailHeader:p,DetailFooter:u,DetailContent:o("VU/8")(g.a,v,!1,f,"data-v-73e8a074",null).exports}},m={render:function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"detail"},[t("detail-header"),this._v(" "),t("detail-content"),this._v(" "),t("detail-footer")],1)},staticRenderFns:[]};var h=o("VU/8")(_,m,!1,function(e){o("t8xF")},"data-v-0aa11dfe",null).exports,b=(o("bZrT"),{render:function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div",{staticClass:"edit"},[o("div",{staticClass:"edit-header"},[o("div",{staticClass:"backto"},[o("span",[o("router-link",{attrs:{to:"/detail"}},[e._v("< 我的博客")])],1)]),e._v(" "),e._m(0),e._v(" "),e._m(1)]),e._v(" "),o("mavon-editor",{ref:"editor",staticClass:"mavon",model:{value:e.doc,callback:function(t){e.doc=t},expression:"doc"}}),e._v(" "),o("div",{staticClass:"checkboxes"},[o("h2",[e._v("文章类型 :")]),e._v(" "),o("label",{attrs:{for:""}},[e._v("vue.js")]),e._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:e.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"vue.js"},domProps:{checked:Array.isArray(e.blog.categories)?e._i(e.blog.categories,"vue.js")>-1:e.blog.categories},on:{change:function(t){var o=e.blog.categories,n=t.target,r=!!n.checked;if(Array.isArray(o)){var s=e._i(o,"vue.js");n.checked?s<0&&e.$set(e.blog,"categories",o.concat(["vue.js"])):s>-1&&e.$set(e.blog,"categories",o.slice(0,s).concat(o.slice(s+1)))}else e.$set(e.blog,"categories",r)}}}),e._v(" "),o("label",{attrs:{for:""}},[e._v("react.js")]),e._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:e.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"react.js"},domProps:{checked:Array.isArray(e.blog.categories)?e._i(e.blog.categories,"react.js")>-1:e.blog.categories},on:{change:function(t){var o=e.blog.categories,n=t.target,r=!!n.checked;if(Array.isArray(o)){var s=e._i(o,"react.js");n.checked?s<0&&e.$set(e.blog,"categories",o.concat(["react.js"])):s>-1&&e.$set(e.blog,"categories",o.slice(0,s).concat(o.slice(s+1)))}else e.$set(e.blog,"categories",r)}}}),e._v(" "),o("label",{attrs:{for:""}},[e._v("node.js")]),e._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:e.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"node.js"},domProps:{checked:Array.isArray(e.blog.categories)?e._i(e.blog.categories,"node.js")>-1:e.blog.categories},on:{change:function(t){var o=e.blog.categories,n=t.target,r=!!n.checked;if(Array.isArray(o)){var s=e._i(o,"node.js");n.checked?s<0&&e.$set(e.blog,"categories",o.concat(["node.js"])):s>-1&&e.$set(e.blog,"categories",o.slice(0,s).concat(o.slice(s+1)))}else e.$set(e.blog,"categories",r)}}}),e._v(" "),o("label",{attrs:{for:""}},[e._v("auguar.js")]),e._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:e.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"auguar.js"},domProps:{checked:Array.isArray(e.blog.categories)?e._i(e.blog.categories,"auguar.js")>-1:e.blog.categories},on:{change:function(t){var o=e.blog.categories,n=t.target,r=!!n.checked;if(Array.isArray(o)){var s=e._i(o,"auguar.js");n.checked?s<0&&e.$set(e.blog,"categories",o.concat(["auguar.js"])):s>-1&&e.$set(e.blog,"categories",o.slice(0,s).concat(o.slice(s+1)))}else e.$set(e.blog,"categories",r)}}})]),e._v(" "),o("div",{staticClass:"describe"},[o("label",{attrs:{for:""}},[e._v("文章说明 :")]),e._v(" "),o("textarea",{directives:[{name:"model",rawName:"v-model",value:e.blog.content,expression:"blog.content"}],domProps:{value:e.blog.content},on:{input:function(t){t.target.composing||e.$set(e.blog,"content",t.target.value)}}})])],1)},staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"edit-search"},[t("label",{attrs:{for:""}}),this._v(" "),t("input",{attrs:{type:"text",placeholder:"输入文章的标题"}})])},function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"button"},[t("button",[this._v("发布文章")])])}]});var y={name:"Detail",data:function(){return{}},components:{DetailHeader:p,DetailFooter:u,AddComponent:o("VU/8")({name:"edit",data:function(){return{blog:{title:"",content:"",categories:[],authod:""},submited:!1}},methods:{}},b,!1,function(e){o("juZ0")},"data-v-11886d1d",null).exports}},x={render:function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"detail"},[t("detail-header"),this._v(" "),t("add-component"),this._v(" "),t("detail-footer")],1)},staticRenderFns:[]};var k=o("VU/8")(y,x,!1,function(e){o("o3KR")},"data-v-88cf6a70",null).exports,w=(o("s6Wf"),o("lchl"),o("mxPT")),q=o.n(w),C={name:"ShowComponent",data:function(){return{id:this.$route.params.id,blog:{},content:""}},created:function(){this.$http.get("../../../../static/blog.json").then(function(e){var t=this,o=e.body.bloglists.filter(function(e){return e.Id==t.id});return this.blog=o[0],console.log(this.blog),o[0]}).then(function(e){var t=e.content;console.log("../../../../static/"+t);var n=o("SgOk")("./"+t);this.content=q()(n)})}},j={render:function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("div",{staticClass:"show-component"},[o("div",{staticClass:"edit-header"},[o("div",{staticClass:"backto"},[o("span",[o("router-link",{attrs:{to:"/detail"}},[e._v("< 我的博客")])],1)])]),e._v(" "),o("div",{staticClass:"content"},[o("h1",[e._v(e._s(e.blog.title))]),e._v(" "),o("article",{staticClass:"markdown-body",staticStyle:{"text-align":"left"},domProps:{innerHTML:e._s(e.content)}})])])},staticRenderFns:[]};var P={name:"Detail",data:function(){return{}},components:{DetailHeader:p,DetailFooter:u,ShowComponent:o("VU/8")(C,j,!1,function(e){o("kEau")},"data-v-7fea21e0",null).exports}},E={render:function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"detail"},[t("detail-header"),this._v(" "),t("show-component"),this._v(" "),t("detail-footer")],1)},staticRenderFns:[]};var A=o("VU/8")(P,E,!1,function(e){o("yzV9")},"data-v-1ad8a1ac",null).exports;n.a.use(a.a);var S=new a.a({routes:[{path:"/",name:"Home",component:c},{path:"/detail",name:"Detail",component:h},{path:"/detail/add",name:"AddBlog",component:k},{path:"/detail/show/:id",name:"ShowBlog",component:A}],mode:"history"}),D=o("J4Ko"),$=o.n(D),O=o("OolZ");o("991W");n.a.config.productionTip=!1,n.a.use($.a),n.a.use(O.a),n.a.filter("to-uppercase",function(e){return e.toUpperCase()}),new n.a({el:"#app",router:S,components:{App:s},template:"<App/>"})},RS5e:function(e,t){},SgOk:function(e,t,o){var n={"./blog":"CCyo","./blog.json":"CCyo","./dapp.md":"lchl","./html+css.md":"Df8s","./js上.md":"el5o","./js下.md":"eu25"};function r(e){return o(s(e))}function s(e){var t=n[e];if(!(t+1))throw new Error("Cannot find module '"+e+"'.");return t}r.keys=function(){return Object.keys(n)},r.resolve=s,e.exports=r,r.id="SgOk"},bZrT:function(e,t){},el5o:function(e,t){e.exports="<p>静态语言（强类型语言） 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 </p> <p>例如：C++、Java、Delphi、C#等。 动态语言（弱类型语言） 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。</p> <p>1、script标签如果是引入外部的js文件,这个标签中不要添加内容~ 2、变量名是地址的别名 ，可以通过变量名访问变量 3、null表示空值、 可以对一个变量赋值是null，NaN 不是一个数 一般用 ！exp判断是不是空（但是不严谨）</p> <p>4、parseInt(true) ------结果 nan</p> <pre><code>隐式转换\n==是比较运算符，所有两边都是转成Number型。[ ]转成0，true转成1\n！是逻辑运算符，所以会转成Boolean，[ ]转成true,前面加！！所以还是true\n 两个不是值的值比较不可能相等</code></pre><p>进制转换：num.toString(2)；---结果是字符串</p> <p>5、if只要第一个条件满足了 后面的哪怕true也不会执行 了------好像不对</p> <p>6、break 是跳出循环 和switch的---不是跳if的 continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内</p> <p>7、//var arr1=new Array(10,80,60,50,20,30,40); //console.log(typeof arr1);/* 放回的是object<em>/ --------------------------联想原型 arr1=[10,80,60,50,20,30,40]; console.log(typeof arr1); /</em> 放回的是object*/</p> <pre><code>类型： 基本类型 number boolean null string undefined\n        引用类型  object               --------这些都是typeof会返回的值\n\n        引用类型 内部又包括 （Object Array Math RegExp Date Error  | 包装类型：Number String Boolean ）</code></pre><p>8、函数没有返回值，却调用的时候用变量接收了，那么结果就是undefined； 函数调用，如果某个参数没穿，这个值就是undefined function apt(a,b){ console.log(a+&quot;----&quot;+b) } apt(2) // 2------undefined；</p> <pre><code>另外：\nvar b=function(d,k,l){console.log(&quot;gsfg&quot;)};\n\nconsole.log(b.length)//返回形参的个数</code></pre><p>9、函数也是一种数据类型： typeof func_name； 结果是function---------------------联想原型</p> <p>10、函数表达式： var f1=function (){ console.log(&quot;dfasdf&quot;); }； f1();//函数调用； 这里的函数调用可以 这样理解：f1相当于是变量 赋值的值是函数代码 加上（） 就是调用 //（<strong><strong>*****</strong></strong>）本身函数调用实质 就是 函数代码+（）；</p> <p>（<strong>*****</strong>）如何定义一个动态函数名的函数：</p> <p> var funcname=“fasdasd”； window[funcname]=function(){}</p> <p>11、声明的变量是var声明的，那么这个变量就是全局变量；全局变量就可以在页面任何位置使用； 除了在函数以外，其他的任何位置定义的变量都是全局变量； 全局变量 是可以跨script标签使用的 --------（<strong><strong><strong>**</strong></strong></strong>）很厉害呀</p> <p>局部变量：在函数内部的定义的变量，是局部变量；只能在函数内部被调用；函数调用结束之后 内存就释放；也是var调用的</p> <pre><code>  函数内部用的不是局部变量的话  结束就不会被释放；\n函数内部调用的值；若本层中没有定义该局部变量，会去看看它的上一级 有没有同名的变量存在\n      如果有的话，会去调用这个；一次从里向外找；</code></pre><p>12、作用域链： 在一个函数中使用一个变量，先在该函数中搜索这个变量，找到了则使用，找不到则继续 向外面找这个变量，找到则使用，一直找到全局作用域，找不到则是undefined；</p> <p>13、预解析： 变量声明 var n 和 函数声明 function（）{console.log(&quot;...&quot;)}都会提前到当前作用域的最上方 所以函数声明在前在后 不影响调用执行 另外 script的标签内的也是一个作用域 只能提前到当前的script标签内部上方</p> <p>函数提升大于变量提升，变量提升会提升到除函数声明的后面；</p> <p>14、对象： new Object（） 字面量方式 自定义构造函数 通过自定义构造函数定义的 下面的结果是true（****-------------------------------------------------联想原型 先了解 ） console.log(obj instanceof Person) 放回true instanceof 表示 是引用类型的变量 obj instanceof Person ---前面是变量 后面是构造函数的名字（书上叫引用类型） Person 叫一种引用类型</p> <p>15、访问对象的两种方式： 点访问和[]访问；</p> <p>对于点访问 无论属性的键 带不带双引号，在访问时候加不了双引号；（可以访问带双引号的键值）</p> <p>对于[]访问 访问属性的时候，不管属性的键带不带双引号，则访问的都要带双引号（此时引号不能省），----在控制台上面测试的</p> <p>16、遍历对象 for (var key in json){}</p> <p>17、11-5-4 是很重要的一节 ----------------自己懂了 主要介绍两点： 基本类型值和引用类型 解析器会做不同处理 在 复制变量值 和 函数传递参数的时候 会有区别 -----对象中存入的是地址 函数传递也是传值 所以 函数内部操作属性方法 会改变外面的对象的 结构</p> <pre><code>对象中也是这样存储的；  4-28   见 11-5-4   有测试里：\n      objtest={a:&quot;123&quot;,b:[1,2,3],c:{&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;2&quot;},func:function(a,b){return a+b}}\n        var k1=objtest.a;\n        k1=&quot;234&quot;;\n        console.log(objtest);  //原对象没有改变\n        var a1=objtest.b;\n        a1[2]=7;\n        console.log(objtest);   //原对象改变了； 因为传递的是地址\n        console.log(a1[2]);\n        a1=[6,7,8];\n        console.log(objtest);\n        console.log(a1);</code></pre><p>18、静态对象（不需要实例化对象 直接调用） 和 实例对象（实例化以后 对实例进行调用） 实例方法----必须通过new的方式创建的对象（实例对象）来调用方法； 静态方法----直接通过大写的构造函数的名字调用的方法 如：String.fromCharCode()</p> <p>19、string 和String对象 普通的string是没有方法的 在调用方法的时候 会去先包装成String对象 在调用方法</p> <p> 字符串的不可变性：var string=&quot;hello&quot;; string[1]=&quot;w&quot; //这个是不可以操作的； --------记住就好 可能和语言底层设计有关； 字符串可以遍历；</p> <p>20 如何判断一个对象属性和方法是不是存在的 if（obj[name]）{}</p> <p>21、常见内置对象的方法： Math.ceil(Math.random()*5) 生成 0-5的方法 也可以用parseInt（） 字符串： 1、str.indexOf(&quot;xiadasdo&quot;,5); 从下标5开始找 ，没找到返回-1；----通常用于判断是否拥有某个字符串 2、str.match(); ---正则表达式（replace也只支持正则表达式）</p> <p>-------这是一个不改变自身实例的一个方法------------ 3、str=str.replace(str1，str2) 替换值 在str中 把str1 换成str2 但是 str没有改变 要用一个返回值接住 再用str 就是的到改变后的了 例子： var str1=&quot;起码的是五分豪情&quot;; str2=str1.replace(&quot;五分&quot;,&quot;十分&quot;); console.log(str1); //起码的是五分豪情 console.log(str2); //起码的是十分豪情</p> <pre><code>    4、str.slice(start,end)  ---截取切片；没有end   返回的是截取后的片段  依然不改变原有实例；\n    5、str.concat()\n    6、str.split(&quot;&quot;)  返回数组\n    7、substring(start，end)  也是切字符串  （） （****于slice的区别是）  substring() 不接受负的参数。\n\n   8.match() ---查找字符串\n            var str = &quot;今天天气好好&quot;;\n            var result = str.match(&quot;天天&quot;);\n             console.log(result);//[&quot;天天&quot;, index: 1, input: &quot;今天天气好好&quot;, groups: undefined]\n   9.search()-----查找字符串返回下标\nvar str = &quot;今天天气天天好好&quot;;\n        var result = str.search(&quot;天天&quot;);\n        console.log(result);//1\n\n  10、includes--检测是否包含指定字符串\n\n\n 数组方法：\n    arr.every(function（ele,index，arr本身）) 用来测试数组的每个元素；返回布尔类型 (如果所有的元素都复合条件，才返回true)\n\n    arr.filter(func),  返回数组中每一个元素都复合条件的元素，组成了一个新的数组</code></pre><p>---------这几种方法 调用就会改变调用它们的对象 arr直接变---------叫变异方法： .push(val): 在数组后面追加一个val； 返回值是追加的值 .pop(): 删除最后一个元素；返回值是删除的值 .shift(): 删除数组中的第一个元素； 返回值是删除的值 .unshift(): 向数组的第一个元素前面插入一个新的元素 .sort() 但是排序不稳定 （sort中也可以传函数，写固定的函数就稳定了） 函数的写法也有讲究：return 1 0 -1； //形参的a,b 相当于以前 a[j],a[j+1]</p> <pre><code>     .splice(index,要删除的个数,val)  //返回的是 切的以后的值  在index后面添加val    ，一般是用于删除数组中的元素；\n                          或是替换元素，或是插入元素；\n            .splice(index,1)------删除index元素；，index也算；  -------只删除不替换\n\n     关于数组方法splice用法：\n\n        splice（1，0，&#39;Tom&#39;）：表示在索引为1的元素前面（注意是前面插入）插入元素’Tom‘（也可以理解为从索引为1的元素开始\n        删除，删除0个元素，再在索引为1的元素前面添加元素&#39;Tom&#39;）；\n\n        splice（1，1，&#39;Tom&#39;）：表示从索引为1的元素开始删除（包括索引为1的元素），共删除1个元素，并添加\n        元素&#39;Tom&#39;。即把索引为1的元素替换为元素&#39;Tom&#39;。</code></pre><hr> <p>-------这是一个不改变自身实例的一个方法------------</p> <pre><code>    .slice(firstindex，lastindex)  // 切一部分返回一个数组，不包含结束的索引\n.slice(0)   就是不切返回（相当于克隆一个新的）\n    高手代码里看到.slice(0)，查了下这样写的好处：\n1.对原数组进行深拷贝，这样进行一系列操作的时候就不影响原数组了；\n\n2.将类数组对象转化为真正的数组对象：var anchorArray = [].slice.call(document.getElementsByTagName(‘a’), 0); \n\n   arr1.concat(arr2) -----------组合数组 不改变arr1 和arr2\n\n    .foreach(func):  遍历数组  相当于for循环 -----内置的回调函数 可以实现对每一个元素操作\n            var arr=[10,20,30];\n            arr.forEach(function (ele,index) {\n                console.log(ele+&quot;===&quot;+index)\n            });\n\n    arr.indexOf(val):  //返回的是索引，没有就是-1；\n\n    .join(&quot;|&quot;)   //  返回字符串；\n\n    .map(func):  数组中的所有元素都要执行一次这个方法~ ,把执行后的结果重新放在一个新的数组中；</code></pre><p>总结： 这些方法 有的会对调用实例 产生改变 ，有的不会 ，有的因为功能在于 其返回值 一个不关心调用实例是否变化，一个也肯定不会变化</p> <pre><code>    主要在意那些会对调用实例 改变的方法  数组中的有 splice push pop shift unshift（插入） sort\n                                           字符串中目前没有</code></pre><p>22、基本包装类型： 本身是基本类型；但在执行代码过程中，如果这个类型的变量调用了属性或者是方法 那么这种类型就不再是基本类型了，而实基本包装类型，这个变量也不是普通的变量了，而实基本包装类型对象；</p> <pre><code>var num=10;\nconsole.log(num.toString())\nconsole.log(typeof num)---------还是number  可能是应该 该方法 不会对调用实例做改变？？  这和语言的设计有关</code></pre><p>JS 中值的类型分为原始值类型和对象类型。原始值类型包括 number, string, boolean, null 和 undefined；对象类型即 object。首先原始值类型它就不是对象。 另外，要注意 &#39;hello&#39; 和 new String(&#39;hello&#39;) 的区别，前者是字符串字面值，属于原始类型，而后者是对象。用 typeof 运算符返回的值也是完全不一样的： 1 2 typeof &#39;hello&#39;; // &#39;string&#39; typeof new String(&#39;hello&#39;); // &#39;object&#39; 之所以很多人分不清字符串字面值和 String 对象，归根结底就是 JS 的语法对你们太过纵容了。当执行 &#39;hello&#39;.length 时，发现可以意料之中的返回 5， 你们就觉得 &#39;hello&#39; 就是 String 对象，不然它怎么会有 String 对象的属性。 其实，这是由于 JS 在执行到这条语句的时候，内部将 &#39;hello&#39; 包装成了一个 String 对象，执行完后，再把这个对象丢弃了， 这种语法叫做 “装箱”，在其他面向对象语言里也有（如 C#）。不要认为 JS 帮你装箱了，你就可以在写代码的时候不分箱里箱外了</p> <p>js的单线程环境、定时器运行---<a href=https://blog.csdn.net/Febby_/article/details/94763441>https://blog.csdn.net/Febby_/article/details/94763441</a> 在所有同步任务执行完之前，任何的异步任务是不会执行的</p> <p>//console.log(parseInt(true))// 结果是NaN 因为 （会先默认转成字符串 ---所以是nan）</p> <pre><code> //if 判断 true了后  后面的不会执行\n// var num1=10;\n//  if(num1&gt;5){\n//      console.log(&quot;dayu &quot;)\n//  }else if(num1&gt;6){\n//      console.log(&quot;fasdfasd&quot;)\n//  }</code></pre><p> //预解析的例子 // function f1() { // console.log(num);//undefined // var num=10; // } // f1(); // console.log(num);// 报错</p> <p> // 跨script标签的预解析： // var num=10; function f1() { console.log(&quot;哈哈&quot;); } f1() console.log(num)</p> <p>----/script ----script----</p> <pre><code>  var  num=10;\nf1();\nfunction f1() {\n  console.log(&quot;嘎嘎&quot;);\n}\nconsole.log(num)</code></pre>"},eu25:function(e,t){e.exports='<p>1、对象： -------（所以一般对象 指的是实例化以后的）</p> <p>2、对象中的属性是 基本类型的怎么存储？？？？</p> <p>3、console.dir(per)的结果是 其构造函数定义的属性和方法（是赋值之后的）+<em>proto</em>(里面有一个constructor和<em>proto</em>) console.dir(Person)的结果 构造函数内容 + prototype+ <strong>proto</strong>（函数自己的原型Function.prototype）</p> <p> 本来是 console.log(per.<strong>proto</strong>.constructor==Person);===》规定这样console.log(per.constructor==Person);// true 虽然per并没有这个constructor属性的；</p> <p>注：console.dir(Person) 的结果 里面的Person.prototype.constructor 也有自己的构造函数： --------------------注意</p> <p> 关系可以在三者关系的图中反应出来；</p> <p>实例对象dir后 会显示 定义的属性和方法（是赋值之后的） 构造函数内容中 并没有这些属性和方法 （没有 age和name 等）</p> <p>4、进一步通过原型解释实例对象和 构造函数的结构</p> <pre><code>* 构造函数可以实例化对象\n* 构造函数中有一个属性叫prototype,是构造函数的原型对象\n* 构造函数的原型对象(prototype)中有一个constructor构造器,这个构造器指向的就是原型对象所在的构造函数\n* 实例对象的原型对象(__proto__)指向的是该构造函数的原型对象\n* 构造函数的原型对象(prototype)中的方法是可以被实例对象直接访问的（*******）</code></pre><p>通过原型添加的方法 可以实现数据共享 这个方法也只有在实例对象的原型中可以找到，实例对象可以用其原型的方法</p> <pre><code>* 构造函数的原型对象(prototype)中有一个constructor构造器,这个构造器指向的就是该原型对象所在的构造函数</code></pre><p>（因为原型对象是在构造函数结构 内部的 构造函数.prototype ）</p> <p>另外： //实例对象的原型<strong>proto</strong>指向的是该对象所在的构造函数的原型对象 //构造函数的原型对象(prototype)指向如果改变了,实例对象的原型(<strong>proto</strong>)指向也会发生改变</p> <p>5、原型的第一个作用就是共享数据 ---节约资源 简单写法中需要手动指定构造器的指向 constructor:Student,</p> <p>6、原型中的方法,是可以相互访问的</p> <pre><code>背景： //实例对象的方法,是可以相互调用的\n   而 原型中的方法也是可以相互访问的：（在调用eat（）中调用play）</code></pre><p>7、实例对象使用的属性或者方法,先在实例中查找, 找到了则直接使用,找不到则,去实例对象的<strong>proto</strong>指向的</p> <p>8、局部变量变成全局变量： 把这个局部变量给 window 就可以全局用了 （用到自调用函数 ---window参数是可以不加的 ）</p> <pre><code>这里面应用了js语法中的两点：\n      一、通过函数参数，对象局部修改可以修改，可以实现全局修改；----传入的是一个对象\n      二、window是一个特殊的全局对象 ，window可以省略；  ------直接是num\n\n      //把局部变量给window就可以了\n  (function () {\n    var num=10;//局部变量\n    //js是一门动态类型的语言,对象没有属性,点了就有了\n    window.num=num;\n  })();\n  console.log(num);</code></pre><p>9、原型链 以及原型的最终指向： 一个原型对象 也是有原型的（这时候 可以看成原型对象是一个 实例对象）， 举例： new Person（） 是通过Person()构造函数实例化出来的 new Person() 是一个实例对象，其原型对象 是Person.prototype ,（person.<strong>proto</strong> 指向 同Person.prototype） 原型对象 也是一个对象 （可以认为它是 new Object 出来的实例对象 所以） 它的原型是 object.prototype</p> <pre><code>（下一级原型相对 上一级 就像是一个实例对象 ）</code></pre><p>10、原型的指向可以改变； ------继承中会用到 Student.prototype=new Person(10); 这里面new Person(10)实例对象（它指向自己的原型对象）就是student的原型对象 （原型链的层又多了一层了<strong><strong>*****</strong></strong>）</p> <p>11、继承--- 组合继承:原型继承+借用构造函数继承（call） function Person(name,age,sex) { this.name=name; this.age=age; this.sex=sex; }</p> <pre><code>      Person.prototype.sayHi=function () {\n        console.log(&quot;阿涅哈斯诶呦&quot;);\n      };\n\n      function Student(name,age,sex,score) {\n        //借用构造函数:属性值重复的问题\n        Person.call(this,name,age,sex);\n        this.score=score;\n      }</code></pre><p>12、this指什么： 普通函数中的this是谁?-----window * 对象.方法中的this是谁?----当前的实例对象 * 定时器方法中的this是谁?----window 定时器是window的方法,相当于window.setInterval， * 构造函数中的this是谁?-----实例对象 * 原型对象方法中的this是谁?---实例对象</p> <p>13、apply和call和blind的使用 只要是想使用别的对象的方法,并且希望这个方法是当前对象的, 那么就可以使用apply或者是call的方法改变this的指向 （也有函数调用的功能）</p> <pre><code>func.apply(对象,[参数1,参数2,...]) 后面的参数是给func的形参  改成 函数是这个传入对象的方法</code></pre><p> //牛客网：---使用闭包 实现函数 makeClosures，调用之后满足如下条件： 1、返回一个函数数组 result，长度与 arr 相同 2、运行 result 中第 i 个函数，即 result<a href="">i</a>，结果与 fn(arr[i]) 相同 //function makeClosures(arr, fn) { // var result=[]; // for(var i=0;i&lt;arr.length;i++){ // result[i]=function(){ // return fn(arr[i]); // } // } // return result //} ---这种写法i是等到执行的时候 i是arr.length;因为闭包中的变量不释放；</p> <pre><code>function makeClosures(arr, fn) {\n    var result=[];\n    for(var i=0;i&lt;arr.length;i++){\n        result[i]=fn.bind(null,arr[i])//  写成fn 没有参数 ，写成fn（arr[i]）是一个调用（***************）\n    }\n    return result\n}</code></pre><p>14、函数作为返回值使用： 个人感觉，1、使用函数作为返回值，可以增加一个函数的参数的的方法： 适用在不方便给函数添加形参的时候，就像arr中的sort方法中的形参函数；他只能传数组中的两个值；</p> <pre><code>      2、 后面结合闭包使用 可以达到缓存值得用法；</code></pre><p>15、闭包：（函数A内部有一个函数B ，函数B用了函数A中的参数） 结合函数作为返回值 （返回的函数就是函数B，形成闭包） 函数作为返回值 ，可以做到 缓存数据功能 三次调用生成同一个随机数 （缓存数据）</p> <p> ----闭包中的变量不会被回收；</p> <p>16、沙箱： (function(){}) 沙箱内部发生的事情并不影响外界的变量； 就像是 一个函数内部</p> <pre><code>沙箱解决了 变量名和函数名冲突的问题，</code></pre><p>17、深拷贝和浅拷贝：----还是得靠百度；</p> <p>18、正则表达式</p> '},juZ0:function(e,t){},kEau:function(e,t){},lchl:function(e,t){e.exports="<h1 id=最小必要知识（后面跟一个空格）>最小必要知识（#后面跟一个空格）</h1> <blockquote> <p> 提到 通过某一个节点作为入口 ----和自己的理解似乎一致</p> <p>称智能合约为：被代码控制的账户</p> </blockquote> <blockquote> <p>智能合约每部署一次 ，产生的实例都是不同的，一个完全不同的账户；</p> </blockquote> <h1 id=开发环境准备>开发环境准备</h1> <h3 id=必要条件1：测试网络节点>必要条件1：测试网络节点</h3> <blockquote> <blockquote> <p>解决办法： 自己搭建私有区块链： 实施成本搞</p> </blockquote> </blockquote> <blockquote> <blockquote> <p> 或者 用Ganache/remix （成本低，本地测试方便，内置就已经解锁账户）</p> <p>或者用共享测试网络： 网络入口节点 infura.io ---------需要有自己的钱包和账户</p> </blockquote> </blockquote> <h3 id=必要条件2：账户和余额>必要条件2：账户和余额</h3> <blockquote> <blockquote> <p>解决办法：使用metamask钱包</p> </blockquote> </blockquote> <h1 id=智能合约工作流---后端>智能合约工作流---后端</h1> <blockquote> <blockquote> <p>在线IDE remix 测试（可以好好的测试调试）</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>vscode+nodejs</p> <p>介绍 彩票原型（是有构造函数的） 用到一个modier函数 ：确保必须得是 合约创建者才能调用</p> </blockquote> <p>通过nodejs部署测试；---组件后端完成（用node进行部署和测试）</p> </blockquote> <h2 id=dapp构建和部署>Dapp构建和部署</h2> "},nP45:function(module,__webpack_exports__,__webpack_require__){"use strict";var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__=__webpack_require__("BO1k"),__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default=__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__),__WEBPACK_IMPORTED_MODULE_1__static_dapp_md__=__webpack_require__("lchl"),__WEBPACK_IMPORTED_MODULE_1__static_dapp_md___default=__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__static_dapp_md__);__webpack_exports__.a={name:"detail-content",data:function(){return{Blogs:[],Categories:[{catename:"html+css",catenum:1},{catename:"js",catenum:1},{catename:"webapi",catenum:1},{catename:"vue",catenum:2},{catename:"node",catenum:1},{catename:"后端ajax",catenum:1},{catename:"es6接触",catenum:1}],search:""}},computed:{filterBlogs:function filterBlogs(){var _this=this;return this.Blogs.filter(function(blog){var reg=eval("/"+_this.search+"/gi");return blog.title.match(reg)})}},created:function(){this.$http.get("../../../../static/blog.json").then(function(e){var t=e.body.bloglists,o=!0,n=!1,r=void 0;try{for(var s,a=__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(t);!(o=(s=a.next()).done);o=!0){var i=s.value;this.Blogs.push(i)}}catch(e){n=!0,r=e}finally{try{!o&&a.return&&a.return()}finally{if(n)throw r}}console.log(this.Blogs)})}}},o3KR:function(e,t){},s6Wf:function(e,t){},t8xF:function(e,t){},tTbG:function(e,t){},vV80:function(e,t){},yzV9:function(e,t){}},["NHnr"]);
//# sourceMappingURL=app.3acae9173d2d5238d7d7.js.map