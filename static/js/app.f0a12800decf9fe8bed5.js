webpackJsonp([1],{0:function(t,e){},"36qd":function(t,e){t.exports="<h1 id=水平垂直居中总结>水平垂直居中总结</h1> <ul> <li><p>水平居中：</p> <p>首先要搞清楚存在两个条件才能够称之为水平居中，即<strong>父元素必须是块级盒子容器</strong>，<strong>父元素宽度必须已经被设定好</strong>，</p> <p>①子元素是块级元素且宽度没有设定：</p> <p>​ 这种情况，子块级默认和父级一样的宽度，所以就相当于已经居中了；如果这个子元素有内容，想让这个内容居中，内容是块级 还是① ，内容是行内元素文本以及行内块元素 跳转到②；</p> <p>②子元素是行内元素文本行内块元素，子元素宽度是由其内容撑开的</p> <p>​ 这种情况下解决方案是给父元素设定text-align:center; </p> <p>③子元素是块级元素且宽度已经设定（已经设定还是没有设定高度都可以用flex）</p> <p>​ 这种情形存在多种解法，下面一一来列举</p> <p> -------------给子元素添加margin:0 auto; <strong>行内块设置这个没用，但是可以设置各margin值</strong></p> <blockquote> <p>注： 加了浮动和定位（不包括relative） ，margin：x auto 就失效了</p> <p>​ <strong><em>是因为变成行内块了；</em></strong></p> </blockquote> <p> -------------设置子盒子定位;</p> <pre><code>            position: absolute;\n            left:50%;\n            margin-left:-子盒子宽度的一半px;\n            或者：\n            transform： translateX（-50%）；</code></pre><p> ------------设置flex：</p> <pre><code>             display:flex;\n            flex-direction: row;\n            justify-content:center;</code></pre></li> <li><p>垂直居中：</p> <p>要讲垂直居中，首先设定两个条件即<strong>父元素是盒子容器</strong>且<strong>高度已经设定</strong></p> <p>①子元素是行内元素，高度是由其内容撑开的----针对单行文本：</p> <p>​ 这种情况下，需要通过设定父元素的line-height为其高度来使得子元素垂直居中 </p> <p>②子元素是块级元素但是子元素高度没有设定，<strong>高度是不继承的</strong></p> <p>-----------通过给父元素设定display:table-cell; vertical-align:middle来解决</p> <p>-----------通过设置父元素flex：</p> <pre><code>            display: flex;\n            flex-direction: column;\n            justify-content: center;</code></pre></li> </ul> <p> ③子元素是块级元素且高度已经设定：</p> <p> ------------利用绝对定位，让子元素相对于父元素绝对定位</p> <pre><code>              position: absolute;\n              top:50%;\n              margin-left:-子盒子高度的一半px;\n              或者：\n              transform： translateY（-50%）；</code></pre><p> ---------------------通过设置父元素flex：</p> <pre><code>              display: flex;\n              flex-direction: column;\n              justify-content: center;</code></pre><ul> <li><p>水平居中+垂直居中：</p> <p>①单行行内元素：</p> <p>​ 父元素设置：text-align:center，display：table-cell;vertical-align:middle,在这里，图片，文字，都是一样的操作</p> </li> </ul> <p>​ ②单个块级元素，父元素设置为相对定位，子元素设置为绝对定位高度，宽度为50%</p> <p>​ ③flex实现不定宽度水平+垂直居中设置父盒子</p> <pre><code>                display: flex;\n                   justify-content:center;\n                   align-items:center;</code></pre>"},"3AWZ":function(t,e){},"95Yj":function(t,e){},"991W":function(t,e){},CCyo:function(t,e){t.exports={bloglists:[{Id:1,title:"html+css内容梳理",content:"html+css.md",category:"html+css",describe:"html认识的所有标签，css选择器权重介绍，定位浮动介绍，精灵图，滑动门，字体图标的使用。h5c3新标签，css3盒子模型，2d变换3d变换，css动画制作",date:"2020-3-12"},{Id:2,title:"js梳理1",content:"js上.md",category:"js",describe:"none",date:"2020-3-25"},{Id:3,title:"js梳理2",content:"js下.md",category:"js",describe:"none",date:"2020-3-30"},{Id:5,title:"标签分类及宽高整理",content:"标签分类及宽高整理.md",category:"html+css",describe:"三类标签的特性，以及宽高设置默认值设置成%的注意事项总结",date:"2020-3-25"},{Id:6,title:"浮动介绍与整理",content:"浮动.md",category:"html+css",describe:"浮动的特性，以及清除浮动的几种方式，最后解释了overflow清除浮动的原理",date:"2020-5-21"},{Id:7,title:"所有的居中方式总结",content:"水平居中垂直居中整理.md",category:"html+css",describe:"提出居中的必要条件，接着介绍各种情况的水平居中和垂直居中的解决方案",date:"2020-5-21"},{Id:8,title:"flex和栅格布局",content:"flex布局整理.md",category:"html+css",describe:"flex属性样式总结+栅格布局，这块需要多用",date:"2020-5-21"}]}},Df8s:function(t,e){t.exports="<h3 id=大案例>大案例\ufeff</h3> <p>一共三个大案例： 云道、京东、学成在线 疑问：通栏居中为什么要用一个盒子嵌套包裹呀； 因为又要通栏又要居中呀</p> <h3 id=查询文档和工具：>查询文档和工具：</h3> <p>标签命名规范：[web前端开发规范手册.doc] ------（<a href=https://www.cnblogs.com/xiaonian0327/p/7735799.html%EF%BC%89>https://www.cnblogs.com/xiaonian0327/p/7735799.html）</a> 常用查询文档： w3c、MDN 拔网页小工具：day12中</p> <hr> <h3 id=后知后觉>后知后觉</h3> <p><strong>div等容器文字只会单行显示</strong></p> <hr> <h3 id=知识点回顾>知识点回顾</h3> <ol> <li>html常见标签</li> </ol> <ol start=2> <li><p>表单与表格 </p> <ul> <li><p>表单中label标签，label中的for属性用于和表单中的id 绑定</p> </li> <li><p>重置按钮和提交按钮 在form中才可以用；</p> </li> <li><p>表格（设置三参为0 border，cellspacing ，cellpadding），介绍合并单元格</p> </li> </ul> </li> </ol> <ol start=3> <li><p>使用css样式表的三种方式：</p> <ul> <li>行内式（偶尔使用）、内部样式表、外部样式表</li> </ul> </li> </ol> <ul> <li><strong>行内权重高，但是只能控制单个标签</strong></li> </ul> <ol start=4> <li><p><strong>css三大特性：</strong></p> <ul> <li>层叠性： 后来的css代码中样式 会覆盖前面的；<pre><code>           注：样式不冲突 ，前面的代码依旧有用，不会被覆盖；</code></pre></li> </ul> </li> </ol> <ul> <li><p>继承性：子标签会继承父标签的 某些样式；</p> <pre><code>    如： color  text-  font-  line- 都是可以继承的；</code></pre><p>​ <strong>但是高 是不继承的；margin和padding是不会继承的（显而易见好吧）</strong></p> </li> </ul> <pre><code> **恰当的利用继承性可以简化代码，降低css样式的复杂性；**</code></pre><ul> <li><p>优先级：行内样式最大；</p> <pre><code>    id选择&gt; 类选择器&gt; 标签选择器；</code></pre><p><strong>权重介绍</strong>: </p> <pre><code>        标签权重  0，0，0，1；\n        类选择器  0，0，1，0；\n        id选择器  0，1，0，0；\n        行内样式  1，0，0，0；\n        ！important 无穷大；\n        * 和继承   0，0，0，0  权重最小；</code></pre><p>注意：</p> <blockquote> <ol> <li><p>权重是可以叠加的：(子代选择器 交集选择器都会叠加)</p> <pre><code>div ul li  0，0，0，3\n.nav ul li 0，0，1，2\na:hover 0,0,1,1;（********）</code></pre></li> <li><p>权重相同 ，则就近原则；</p> </li> <li><p>记住权重是不进位的 0005+0005 ！= 0010 的 而是0，0，0，10；</p> </li> </ol> <ol start=4> <li><strong>父元素的权重再大 继承过后 子元素的权重也还是0；</strong></li> </ol> </blockquote> </li> </ul> <blockquote> <p>伪类选择器书写理解：</p> <p>a:hover .mask （空格 表示后代选择器 表示 a里面的mask显示出来）（<strong>伪类选择器 的这种形式的理解</strong>）</p> </blockquote> <p>​ </p> <ol start=5> <li>标签分类及width和height默认值问题。-----------见自己文档</li> </ol> <ol start=6> <li><p>样式连写总结：</p> <ul> <li><p>字体font</p> <blockquote> <p>font的连写： font：12px/1.5 （表示的是行高 1.5* font-size）</p> </blockquote> </li> <li><p>背景background</p> </li> <li><p>文本（color，text-decoration，text-align、line-height ）</p> </li> </ul> <blockquote> <p><strong>连写的样式覆盖现象</strong></p> <p>transform： translateX（-20px）； transform： scale（0.8） 后面的会覆盖的上面的；</p> </blockquote> </li> </ol> <p>注：<strong>背景位置 background-position</strong></p> <blockquote> <ul> <li><p>background-position : x，y （<strong>可以用方位名词 center top left 也可与px 混合用也可以</strong>）</p> <p>​ 1. positon后面可以跟方位名词 他们之间可以没有上下顺序</p> <pre><code>2. position 如果只写一个方位名词，另外一个默认是居中的\n 3. position 后面也可以跟 值px 但是 必须有顺序 x 在前面 y 后面 不能颠倒 </code></pre></li> </ul> <p> 另外：<strong><em>left top 是默认值；</em></strong></p> <ul> <li><p>background-position设置center</p> <p> <strong>位置中的center 是把背景图放在盒子的中线上；</strong></p> <p> 如果图比盒子大的话 ，图会超出盒子 的 也就是图的中心部分还是在盒子的中心的；</p> </li> </ul> </blockquote> <p>注意：background-attachment了解：</p> <p>​ </p> <ol start=7> <li><p>经常混淆的几个样式：</p> <p>​ 背景透明：rbga() 用在background中 </p> <p>​ &gt; <strong>透明设置方式背景：background： rgba(0,0,0,0.3 )</strong></p> <p>​ 盒子阴影 box-shadow</p> <p>​ &gt; 盒子阴影（css3）box-shadow：水平阴影 垂直阴影 模糊距离 阴影尺寸（就是影子的大小） 颜色 内外阴影（默认外阴影）</p> <p>​ 盒子透明 opacity: <strong>盒子包括盒子的内容都透明</strong></p> <p>​ &gt; 盒子透明 opacity: 0.2; /<em>盒子半透明 字也透明了 盒子也透明了</em>/</p> <p>​ </p> <p>注：<strong>CSS:opacity:0,visibility:hidden,display:none的区别</strong></p> <pre><code>1 opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的,位置还在；\n2 visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n3 display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样</code></pre></li> </ol> <ol start=8> <li>水平居中垂直居中整理------见 自己 文档；</li> </ol> <ol start=9> <li>margin的两种坍塌现象；<strong>子元素带着父元素垂直方向跑；</strong><pre><code>    现象描述： 对于两个嵌套关系的块元素， 如果父元素没有上内边距 和边框 则父元素的\n    上外边距会与子元素的上外边距发生合并 ，合并后的外边距为两者中的较大者，即使父元素\n    的上外边距为0，也会发生合并。</code></pre></li> </ol> <ol start=10> <li><p>在css2盒子模型中；添加padding只会撑开带有width和height的盒子； <strong>没有设置宽高的不会撑开</strong></p> <blockquote> <p>​ 解释：如果一个子盒子没有给定宽度/高度，就会用其父类的属性，这时padding不会影响子盒子的大小(会自适应调节width)</p> </blockquote> </li> </ol> <ol start=11> <li><strong>浮动</strong>---------详情见浮动介绍</li> </ol> <p>​ <strong>浮动并不是完全意义上的脱标（文字不会被盖住 还有图片也是）</strong></p> <p>​ <strong>浮动的盒子跨越不 了父元素 padding和border</strong></p> <blockquote> <p> <strong><em>另外：因为浮动是在原有位置基础上 浮动的( 三个div 中间一个不设置float：left 第三个不是接在第一个div后面的)</em></strong></p> </blockquote> <ol start=12> <li><p><strong>定位</strong></p> <p>定位的主要属性 就是定位模式（static（默认） relative absolute fixed）和边偏移 top left...；</p> </li> </ol> <ul> <li><p>静态定位static 唯一的用处就是取消定位</p> </li> <li><p>相对定位：根据自己的<strong>左上角</strong>进行定位，</p> <p>​ <strong>相对定位 原先的盒子位置依旧是保留的，会是压住标准流中的元素的</strong></p> <p><strong>不会打扰标准流的元素，只会叠盖；只有原有位置影响布局，定位后的位置是不影响布局的</strong></p> </li> <li><p>绝对定位：将元素依据最近的已经定位的 父元素（祖先）进行定位，是脱离标准文档流， 不占位置的 </p> <p>​ <strong>-----完全脱标</strong></p> </li> <li><p>固定定位： <strong>父元素加不加position top和left值都是相对浏览器页面的</strong></p> </li> <li><p>z-index：（叠放次序） 表示的是z轴 ；</p> <blockquote> <p>只有定位（relative，absolute，fixed都有）的盒子才有z-index 浮动 静态定位都是没有z-index的；</p> <p>-z-index取值相同，后来者居上；</p> </blockquote> <p>另外：如果没有设置z-index 相同的 就后来者居上覆盖（<strong>但是并不是说它的z-index 依次变大</strong>）</p> </li> </ul> <blockquote> <p><strong>边偏移 top left</strong></p> <blockquote> <p>left: % 的时候是父元素的盒子宽度的大小；（就是说 width+padding的后的值）</p> </blockquote> </blockquote> <p>补充：<strong>left的值和right的值同时出现的时候</strong></p> <blockquote> <p>定位中left的值和right的值同时出现的时候 以 left和top为准 这个和css的层叠性没关系 也就是和先后设置没关系</p> <p>同时设置margin-left和margin-right也是 以left为准</p> </blockquote> <ol start=13> <li><p>显示与隐藏：</p> <ul> <li><p>opacity:0,</p> </li> <li><p>visibility:hidden,</p> </li> <li><p>display:none</p> </li> </ul> <p>三者区别：</p> <pre><code>1 opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的,位置还在；\n    但是h5c3中用了 position：就可以达到不占位置了\n\n2 visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n3 display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样</code></pre></li> </ol> <ol start=14> <li>鼠标拖拽 轮廓和防止拖拽：</li> </ol> <ul> <li><p>轮廓 outline: ---------一般都是结合表单和表单域使用</p> <pre><code>   outline: none;  *取消轮廓线的做法*/ /*取消蓝色边框*/      或者用outline：0</code></pre></li> <li><p>防止拖拽 防止它影响布局</p> <pre><code>  resize: none;  /*防止拖拽*/</code></pre></li> </ul> <blockquote> <p>​ 不是只有a才可以设置cursor p img div 都可以 ​ cursor: pointer; 让我们的鼠标样式变成小手 ​ cursor: text; 让我们的鼠标样式变成选择 ​ cursor: default; 让我们的鼠标样式小白 ​ cursor: move; 鼠标变成十字架样子</p> </blockquote> <ol start=15> <li>溢出文字隐藏 三个样式； white-space: nowrap; /<em>1.强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行</em>/<pre><code>   overflow: hidden;             /* 2. 超出的部分 隐藏*/\n   text-overflow: ellipsis;       /* 3. 溢出的部分用省略号替代*/</code></pre></li> </ol> <p>​ </p> <ol start=16> <li>*<em>div直接装一个图片出现一条缝隙问题 *</em>-------div没设置 图片的height 高度；</li> </ol> <ul> <li><p>原因：图片和文字等inline行内元素默认是和父级元素的baseline基线对齐的，而baseline又和父级底边有一定距离（这个距离和 font-size，font-family 相关，不一定是 5px）div不设置高度的时候 视其内容撑开盒子；所以导致这个问题</p> </li> <li><p>解决办法： </p> <blockquote> <p>​ 设置盒子div 的 font-size: 0; </p> <p>​ 或者设置盒子div 的line-height: 0; ​ <strong>还有设置img为block</strong></p> </blockquote> </li> </ul> <hr> <h1 id=实操应用部分>实操应用部分</h1> <ol start=18> <li><p>精灵图</p> <ul> <li><p>目的：为了有效地减少服务器接受和发送请求的次数，避免来回跑；</p> <blockquote> <p>​ 产生背景，一个网页中往往会应用很多小的背景图像作为修饰， 当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术(也称CSSSprites、CSS雪碧)。</p> </blockquote> </li> <li><p>操作：设置background-position </p> <p>background: url(images/index.png) no-repeat -2px -184px;</p> </li> </ul> </li> </ol> <pre><code>注：&gt; 不好做的那个精灵图 在 day12 中的携程案例中</code></pre><ol start=17> <li>滑动门<ul> <li>功能：根据内容 框适当变大 也是利用了背景图片：（父子都设置背景）</li> </ul> </li> </ol> <ul> <li><p>结构：</p> <p>​ </p> <pre><code>   &lt;a href=&quot;#&quot;&gt;</code></pre></li> </ul> <pre><code>                 &lt;span&gt;首页&lt;/span&gt;\n     &lt;/a&gt;\n     a 左边放左圆角  但是文字需要向右移动15px\n     span 右边放右圆角  但是文字需要向左移动15px\n     ​       </code></pre><ol start=18> <li><p>字体图标-------自己下载的放到D盘下了 D:\\python\\icomoon</p> <p>看上去是图片 其实是字体 （可以设置font-size） 文字 以小图标的形式展示的；</p> <ul> <li><p>下载字体图标 （ icomoon 德国的和 iconfont 中国）</p> <p>​ 先点左上角的icomoon app ​ 再选择想要的图标 后点击 右下角的generate font ​ 再找右下角的download 下载压缩包iconmoon；</p> <p>​ 解压后 我们只需要<strong>font文件夹</strong>复制到项目中----------用别人的就直接copy这个目录</p> <p>​ 其中的demo.html中是我们要去复制的  ​ styles.css 里面有 @font-face {...}（下载的不同 这里也不同）</p> </li> </ul> </li> </ol> <pre><code>+ 字体图标的使用：\n          首先： @font-face {...} 复制这个内容到style标签中；\n          其次：  在下载的 文件夹中的demo.html文件中 粘贴 想要的图标\n          再： font-family申明字体；(必须要声明font-size中声明的字体)\n\n  &gt;  还有一种伪元素结合图标字体使用；（div::before { content: &quot;\\ea51&quot;;）\n  &gt;\n  &gt; \n\n+ 添加自定义的图标：  点击 import icons（了解）\n      将svg图片导入到 icomoon网站上就可以转换了； svg不可以设置字体大小和颜色；\n      重新下载新的压缩包 新的图标 添加 解决；\n\n\n\n+ 追加新的图标；（又想下载新的图标了）\n       不能合并  得重新下载\n       将 selection.json （方便追加的）导入点击import-icons  再下载就可以重新下载后 再更新index</code></pre><hr> <h1 id=h5c3部分>H5C3部分</h1> <ol start=19> <li><p>h5 新标签和 css选择器： 表单标签 &lt;fieldset&gt; 新增的表单 （type=url等）具有鉴定功能</p> <p> 选择器（ul:last-child 结构伪类， div[class] 属性选择器）</p> </li> </ol> <ol start=20> <li><p><strong>伪元素：（::before 和:: end ）</strong></p> <pre><code>必须带一个属性  content\n**伪元素 其实这个 before 是个盒子,这个盒子是行内  可以转换**</code></pre><p> before 和 after 都是在div的内部的inline-block；</p> </li> <li><p>css3盒子模型：box-sizing</p> <p>width 包括边框 、会自适应调节 盒子内容（就是以前的width）</p> </li> </ol> <ol start=22> <li><p>过渡transition：<strong>加在 要让变化的元素身上</strong></p> <p>`</p> <p> /<em>transition: width 0.5s ease 0s, height 0.3s; 多组属性用逗号分隔</em>/</p> <p>`</p> </li> </ol> <ol start=23> <li><p>移动、放缩、旋转(2d变换transform)</p> <ul> <li><p>移动 translate：</p> <p>transform： translate（x,y） translateX（-20px)；</p> <p>translate（x，y） 只有一个值时 默认y为0；</p> <p> 50% 是走自己<strong>盒子宽度</strong>的一半</p> <p><strong>移动后： 原来的位置还占用，和设置relative一样，不会打扰标准流的元素，只会叠盖；只有原有位置影响布局，移动后的位置是不影响布局的</strong> </p> </li> <li><p>缩放scale： 默认中心点缩放</p> </li> <li><p>旋转rotate： 默认中心点旋转；</p> </li> </ul> </li> </ol> <p>scale和rotate 都可以设置 transform-origin的 </p> <p><strong>另外：缩放放大后的区域 和设置移动元素一样，不会打扰标准流的元素，只会叠盖；只有原有位置影响布局，放大后的位置是不影响布局的</strong></p> <p><strong>设置transform顺序决定变化的顺序，出来的结果也会不一样。</strong></p> <blockquote> <pre><code>transform： translateX（-20px）scale（0.8）  （//先移动 后缩放）</code></pre></blockquote> <p> <strong>3d变化</strong></p> <p> transform: translateX(); translateY()（这两个2d中也有）;translateZ(); translate3d(x,y,z) rotateX() 沿着x轴旋转； 2d旋转用的是 rotate（）、rotateZ()</p> <ol start=24> <li><p>动画制作</p> <p>animation：动画名称 花费时间 运动曲线 何时开始 播放次数（n 或者 infinite） 是否反方向（alternate 反向 normal（直接回原点））;</p> <p><strong>步骤：</strong></p> <blockquote> <pre><code>@keyframes heart {\n   0% {\n      transform: scale(1);\n   }\n\n   50% {\n      transform: scale(1.1);\n   }\n\n   100% {\n      transform: scale(1);\n   }\n}\n//在css样式中使用：\nanimation: heart 0.5s  infinite;  /*一个叫heart 的动画  每隔0.5s 执行动画 无限次*/</code></pre></blockquote> </li> </ol> <ol start=25> <li><p>伸缩布局 ：flex；---------见新的文档</p> <pre><code>父元素设置 diplay:flex; 子元素设置flex份数 ， -----最简单的应用。</code></pre><blockquote> <p>基本规则：</p> <pre><code>    **有margin 先用总的扣掉 再分份数；**\n    **当子元素 设置固定大小时，去掉固定的 剩下的 不固定（伸缩的）分；**</code></pre></blockquote> </li> </ol> <ol start=26> <li><p>一些冷门样式：</p> <ul> <li><p>background-size ：规定背景图片的大小；</p> <p>​ background-size: 100px 100px; -----可以设置百分比哦~</p> <p> <strong>background-size: 100px;------- 如果只有一个值 后面一个值默认为 auto 等比例缩放</strong></p> <p> background-size: cover; 把背景图片尽可能放大；保证图片始终充满背景区域，如有溢出部分则隐藏</p> <p> background-size: contain; 会自动调整缩放比例，保证图片始终完整显示在背景区域</p> </li> </ul> </li> </ol> <pre><code>+ 多背景：background: url(images/2.jpg) no-repeat top left , url(images/3.jpg) no-repeat bottom right;\n+ 背景渐变：background: -webkit-linear-gradient(top, red 0%, green 50%, blue 100%);</code></pre><ol start=27> <li>浏览器前缀<pre><code>-webkit  为了让低版本浏览器支持（谷歌前缀）；\n-moz   让火狐支持 火狐前缀\n-ms  让微软支持</code></pre></li> </ol> <hr> <h2 id=辅助工具ps和fw的操作>辅助工具ps和fw的操作</h2> <ul> <li><p>ps操作：day5----13 标尺；（ctrl+r 显示标尺）右击标尺 改成像素</p> <p> 吸管 ： 可以吸取颜色； 测量宽高： 选中矩形 选框工具（可以测得宽高） 取消选中的 用ctrl+d 辅助线： 直接从标尺中拖拉出来 测量版心 他用了 用顶行的视图 里面有清除所有的辅助线</p> </li> </ul> <p> 切图工具：在切logo的时候用的 切片大小可以调节 再导出 点击 web所用格式： 存储的结果中 ：要选中 选中的切片</p> <p> 删除切片： 用切片选择工具： 选中就删除； 或者用顶行的视图 ： 里面有清除切片 可以清除掉所有的切片；</p> <p>注：不会的操作：</p> <blockquote> <p>(如何看字体的大小 不会弄 ) 如何看一个字体的大小： 选中ps中的文本框：</p> <p> ps中的图层的操作 ： 删除了图中的几个小圆点</p> <p> 图层切图 这块不行</p> </blockquote> <ul> <li>fw操作（精灵图最佳）---day7 滑动门</li> </ul> "},L9eU:function(t,e){t.exports="<h1 id=浮动>浮动</h1> <p>最早是用来实现文字环绕图片的；现在目的就是为了让多个块级元素在同一行上显示（同一行上显示以前用inner-block做的， 但是它实现不了 靠页面右边显示。还有一个是inner-block 是有缝隙的）</p> <ul> <li>浮动特性：</li> </ul> <p>浮: 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。</p> <p>漏: 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏给了标准流的盒子。<strong>一种特殊的脱标</strong></p> <p>特: 特别注意，首先浮动的盒子需要和标准流的父级搭配使用，其次特别的注意浮动可以使元素显示模式体现为<strong>行内块特性</strong>。</p> <p>​ </p> <p><strong>浮动并不是完全意义上的脱标（文字不会被盖住 还有图片也是）</strong></p> <p><strong>浮动的盒子跨越不 了 padding和border</strong></p> <blockquote> <p> <strong><em>另外：因为浮动是在原有位置基础上 浮动的( 三个div 中间一个不设置float：left 第三个不是接在第一个div后面的)</em></strong></p> </blockquote> <p> 浮动有不好的地方：会影响后面的布局 ；给高度确实不影响后面的布局，但是也有的时候 父元素不方便设置高度的时候）</p> <ul> <li><p>清除浮动：<strong>本质就是： 为了解决父级元素因为子级浮动而引起内部高度为0 的问题；</strong></p> <p>清除浮动的四种方式：</p> <pre><code>  父元素设置高度，额外标签法，父元素设置overflow：hidden；伪元素清除浮动</code></pre><ul> <li><p>额外标签法： 在最后一个浮动元素的后面添加一个空盒子<strong>（clear：both）</strong></p> </li> <li><p>父元素添加overflow： 给overflow设置一个值 ： hidden auto 或者scroll</p> </li> <li><p>伪元素清除浮动：原理还是额外标签法</p> <pre><code>    .clearfix:after {  /*正常浏览器 清除浮动*/\n           content:&quot;&quot;;\n           display: block;\n          height: 0;\n           clear: both;\n           visibility: hidden;\n    }\n    .clearfix {\n           *zoom: 1;  /*zoom 1 就是ie6 清除浮动方式  *  ie7一下的版本所识别*/\n    }</code></pre></li> </ul> </li> </ul> <p>参考网址：<a href=https://blog.csdn.net/ParanoidYang/article/details/62062828>https://blog.csdn.net/ParanoidYang/article/details/62062828</a></p> "},N6U1:function(t,e){},NHnr:function(t,e,o){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var n=o("7+uW"),r={render:function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{id:"app"}},[e("router-view")],1)},staticRenderFns:[]};var l=o("VU/8")({name:"App"},r,!1,function(t){o("N6U1")},null,null).exports,i=o("/ocq"),s={render:function(){var t=this.$createElement;return(this._self._c||t)("div",{staticClass:"home"},[this._v("\n  博客的首页\n")])},staticRenderFns:[]};var a=o("VU/8")({name:"Home",data:function(){return{}}},s,!1,function(t){o("vV80")},"data-v-51bef7c0",null).exports,p={render:function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("header",[o("div",{attrs:{id:"hd_info"}},[o("div",{attrs:{id:"my_motto"}},[t._v(t._s(t.motto))]),t._v(" "),t._m(0),t._v(" "),o("div",{staticClass:"clear"})]),t._v(" "),o("div",{attrs:{id:"header"}},[o("p",{staticClass:"h_r_3"}),o("p",{staticClass:"h_r_2"}),o("p",{staticClass:"h_r_1"}),t._v(" "),o("div",{attrs:{id:"bloger"}},[o("h1",[t._v(t._s(t.bloger)+"小可爱的博客")])]),t._v(" "),o("p",{staticClass:"h_r_1"}),o("p",{staticClass:"h_r_2"}),o("p",{staticClass:"h_r_3"})]),t._v(" "),o("div",{attrs:{id:"nav_menu"}},[o("router-link",{attrs:{to:"/"}},[t._v("所有博客")]),t._v(" "),o("router-link",{attrs:{to:"/add"}},[t._v("添加博客")]),t._v(" "),o("a",{attrs:{href:"#"}},[t._v("关于我")]),t._v(" "),o("a",{attrs:{href:"#"}},[t._v("找找看")])],1)])},staticRenderFns:[function(){var t=this.$createElement,e=this._self._c||t;return e("div",{attrs:{id:"login_area"}},[e("span",{attrs:{id:"span_userinfo"}},[this._v("["),e("a",{attrs:{href:"#"}},[this._v("登录")]),this._v("·"),e("a",{attrs:{href:"#"}},[this._v("注册")]),this._v("]")])])}]};var c=o("VU/8")({name:"detail-header",data:function(){return{motto:"多一些不为什么的坚持~",bloger:"crisiya824"}}},p,!1,function(t){o("ZsQh")},"data-v-3930731e",null).exports,d={render:function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("footer",[o("footer",[o("ul",{staticClass:"scroll-link",on:{click:t.toTop}},[t._m(0)]),t._v(" "),o("div",{staticClass:"footer-wrap"},[o("div",{staticClass:"w main-footer"},[o("div",{staticClass:"foot-top clearfix"},[t._m(1),t._v(" "),t._m(2),t._v(" "),o("div",{staticClass:"right follow"},[o("a",{staticClass:"concat",attrs:{href:"#"}},[t._v("Follow @ "+t._s(t.bloger))]),t._v(" "),o("ul",[o("li",{staticClass:"emial"},[t._v("邮箱: "+t._s(t.email))]),t._v(" "),o("li",{staticClass:"phone"},[t._v("电话: "+t._s(t.phone))])])])])])]),t._v(" "),o("div",{staticClass:"footer-bottom"},[o("div",{staticClass:"w xiamian-footer"},[o("div",{staticClass:"created-time left"},[o("a",{staticClass:"logo",attrs:{href:"/"}},[t._v("Storenvy")]),t._v("\n                  Design by © "+t._s(t.data)+".  All Rights Reserved."),o("br")]),t._v(" "),t._m(3)])])])])},staticRenderFns:[function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("a",{attrs:{href:"#"}},[this._v("Back to TOP")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"foot-list"},[e("ul",[e("li",[e("a",{attrs:{href:"#"}},[this._v("Blog Home")])]),this._v(" "),e("li",[e("a",{attrs:{href:"#"}},[this._v("Popular items")])]),this._v(" "),e("li",[e("a",{attrs:{href:"#"}},[this._v("Newest items")])]),this._v(" "),e("li",[e("a",{attrs:{href:"#"}},[this._v("Privated items")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"foot-list row2"},[e("ul",[e("li",[e("a",{attrs:{href:"#"}},[this._v("Github")])]),this._v(" "),e("li",[e("a",{attrs:{href:"#"}},[this._v("CSDN")])]),this._v(" "),e("li",[e("a",{attrs:{href:"#"}},[this._v("Tecent Cloud")])])])])},function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("div",{staticClass:"bottom-center"},[o("a",{attrs:{href:"#"}},[t._v("Press Kit")]),t._v(" "),o("a",{attrs:{href:"#"}},[t._v("Terms")]),t._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[t._v("Privacy")]),t._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[t._v("Creative Rights")]),t._v(" ·\n                  "),o("a",{attrs:{href:"javascript:;"}},[t._v("Contact Us")]),t._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[t._v("Support@Storenvy.com")]),t._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[t._v("Support & FAQ")]),t._v(" ·\n                  "),o("a",{attrs:{href:"#"}},[t._v("Copyright")])])}]};var u=o("VU/8")({name:"detail-footer",data:function(){return{bloger:"cirsiya824",data:"2020/5/18",email:"************@163.com",phone:"1**********"}},methods:{toTop:function(){}}},d,!1,function(t){o("tTbG")},"data-v-0415abcd",null).exports,g=o("nP45"),f={render:function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("div",{staticClass:"blog-content"},[o("div",{staticClass:"header"},[t._m(0),t._v(" "),o("div",{staticClass:"search"},[o("input",{directives:[{name:"model",rawName:"v-model",value:t.search,expression:"search"}],attrs:{type:"text",placeholder:"搜索"},domProps:{value:t.search},on:{input:function(e){e.target.composing||(t.search=e.target.value)}}}),t._v(" "),o("button",[t._v("找找看")])])]),t._v(" "),o("div",{staticClass:"blog-exhition"},[t._l(t.filterBlogs,function(e){return o("div",{staticClass:"single-blog"},[o("router-link",{attrs:{to:"/show/"+e.Id}},[o("div",{staticClass:"title"},[o("span",{staticClass:"create-type"},[t._v("原创")]),t._v(" "),o("h2",[t._v(t._s(t._f("to-uppercase")(e.title)))])]),t._v(" "),o("article",[t._v(t._s(e.describe))]),t._v(" "),o("div",{staticClass:"blog-describe"},[o("span",{staticClass:"create-date"},[t._v(t._s(e.date))]),t._v(" "),o("span",{staticClass:"blog-category"},[t._v("文章类型 : "+t._s(e.category))])])])],1)}),t._v(" "),o("div",{staticClass:"categories-exhibition"},[o("h3",[t._v("分类专栏")]),t._v(" "),o("div",{staticClass:"categories-content"},[o("ul",t._l(t.Categories,function(e){return o("li",{staticClass:"typeitem"},[o("a",{attrs:{href:"#"}},[o("span",{staticClass:"catename"},[t._v(t._s(e.catename))]),t._v(" "),o("span",{staticClass:"catenum"},[t._v(t._s(e.catenum)+"篇")]),t._v(" "),o("div",{staticClass:"clear"})])])}),0)])])],2)])},staticRenderFns:[function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"header-title"},[e("span",[e("a",{attrs:{href:"#"}},[this._v("我的博客")])]),this._v(" > "),e("span",[e("a",{attrs:{href:"#"}},[this._v("博客目录")])])])}]};var h=function(t){o("95Yj")},m={name:"Detail",data:function(){return{}},components:{DetailHeader:c,DetailFooter:u,DetailContent:o("VU/8")(g.a,f,!1,h,"data-v-429146b2",null).exports}},v={render:function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"detail"},[e("detail-header"),this._v(" "),e("detail-content"),this._v(" "),e("detail-footer")],1)},staticRenderFns:[]};var _=o("VU/8")(m,v,!1,function(t){o("t8xF")},"data-v-0aa11dfe",null).exports,b=(o("bZrT"),{render:function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("div",{staticClass:"edit"},[o("div",{staticClass:"edit-header"},[o("div",{staticClass:"backto"},[o("span",[o("router-link",{attrs:{to:"/"}},[t._v("< 我的博客")])],1)]),t._v(" "),t._m(0),t._v(" "),t._m(1)]),t._v(" "),o("mavon-editor",{ref:"editor",staticClass:"mavon",model:{value:t.doc,callback:function(e){t.doc=e},expression:"doc"}}),t._v(" "),o("div",{staticClass:"checkboxes"},[o("h2",[t._v("文章类型 :")]),t._v(" "),o("label",{attrs:{for:""}},[t._v("vue.js")]),t._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:t.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"vue.js"},domProps:{checked:Array.isArray(t.blog.categories)?t._i(t.blog.categories,"vue.js")>-1:t.blog.categories},on:{change:function(e){var o=t.blog.categories,n=e.target,r=!!n.checked;if(Array.isArray(o)){var l=t._i(o,"vue.js");n.checked?l<0&&t.$set(t.blog,"categories",o.concat(["vue.js"])):l>-1&&t.$set(t.blog,"categories",o.slice(0,l).concat(o.slice(l+1)))}else t.$set(t.blog,"categories",r)}}}),t._v(" "),o("label",{attrs:{for:""}},[t._v("react.js")]),t._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:t.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"react.js"},domProps:{checked:Array.isArray(t.blog.categories)?t._i(t.blog.categories,"react.js")>-1:t.blog.categories},on:{change:function(e){var o=t.blog.categories,n=e.target,r=!!n.checked;if(Array.isArray(o)){var l=t._i(o,"react.js");n.checked?l<0&&t.$set(t.blog,"categories",o.concat(["react.js"])):l>-1&&t.$set(t.blog,"categories",o.slice(0,l).concat(o.slice(l+1)))}else t.$set(t.blog,"categories",r)}}}),t._v(" "),o("label",{attrs:{for:""}},[t._v("node.js")]),t._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:t.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"node.js"},domProps:{checked:Array.isArray(t.blog.categories)?t._i(t.blog.categories,"node.js")>-1:t.blog.categories},on:{change:function(e){var o=t.blog.categories,n=e.target,r=!!n.checked;if(Array.isArray(o)){var l=t._i(o,"node.js");n.checked?l<0&&t.$set(t.blog,"categories",o.concat(["node.js"])):l>-1&&t.$set(t.blog,"categories",o.slice(0,l).concat(o.slice(l+1)))}else t.$set(t.blog,"categories",r)}}}),t._v(" "),o("label",{attrs:{for:""}},[t._v("auguar.js")]),t._v(" "),o("input",{directives:[{name:"model",rawName:"v-model",value:t.blog.categories,expression:"blog.categories"}],attrs:{type:"checkbox",value:"auguar.js"},domProps:{checked:Array.isArray(t.blog.categories)?t._i(t.blog.categories,"auguar.js")>-1:t.blog.categories},on:{change:function(e){var o=t.blog.categories,n=e.target,r=!!n.checked;if(Array.isArray(o)){var l=t._i(o,"auguar.js");n.checked?l<0&&t.$set(t.blog,"categories",o.concat(["auguar.js"])):l>-1&&t.$set(t.blog,"categories",o.slice(0,l).concat(o.slice(l+1)))}else t.$set(t.blog,"categories",r)}}})]),t._v(" "),o("div",{staticClass:"describe"},[o("label",{attrs:{for:""}},[t._v("文章说明 :")]),t._v(" "),o("textarea",{directives:[{name:"model",rawName:"v-model",value:t.blog.content,expression:"blog.content"}],domProps:{value:t.blog.content},on:{input:function(e){e.target.composing||t.$set(t.blog,"content",e.target.value)}}})])],1)},staticRenderFns:[function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"edit-search"},[e("label",{attrs:{for:""}}),this._v(" "),e("input",{attrs:{type:"text",placeholder:"输入文章的标题"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"button"},[e("button",[this._v("发布文章")])])}]});var x={name:"Detail",data:function(){return{}},components:{DetailHeader:c,DetailFooter:u,AddComponent:o("VU/8")({name:"edit",data:function(){return{blog:{title:"",content:"",categories:[],authod:""},submited:!1}},methods:{}},b,!1,function(t){o("3AWZ")},"data-v-576fc60c",null).exports}},k={render:function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"detail"},[e("detail-header"),this._v(" "),e("add-component"),this._v(" "),e("detail-footer")],1)},staticRenderFns:[]};var w=o("VU/8")(x,k,!1,function(t){o("o3KR")},"data-v-88cf6a70",null).exports,y=(o("s6Wf"),o("lchl"),o("mxPT")),q=o.n(y),C={name:"ShowComponent",data:function(){return{id:this.$route.params.id,blog:{},content:""}},created:function(){this.$http.get("../../../../static/blog.json").then(function(t){var e=this,o=t.body.bloglists.filter(function(t){return t.Id==e.id});return this.blog=o[0],console.log(this.blog),o[0]}).then(function(t){var e=t.content;console.log("../../../../static/"+e);var n=o("SgOk")("./"+e);this.content=q()(n)})}},j={render:function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("div",{staticClass:"show-component"},[o("div",{staticClass:"edit-header"},[o("div",{staticClass:"backto"},[o("span",[o("router-link",{attrs:{to:"/"}},[t._v("< 我的博客")])],1)])]),t._v(" "),o("div",{staticClass:"content"},[o("h1",[t._v(t._s(t.blog.title))]),t._v(" "),o("article",{staticClass:"markdown-body",staticStyle:{"text-align":"left"},domProps:{innerHTML:t._s(t.content)}})])])},staticRenderFns:[]};var P={name:"Detail",data:function(){return{}},components:{DetailHeader:c,DetailFooter:u,ShowComponent:o("VU/8")(C,j,!1,function(t){o("SZq+")},"data-v-8b230a7e",null).exports}},E={render:function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"detail"},[e("detail-header"),this._v(" "),e("show-component"),this._v(" "),e("detail-footer")],1)},staticRenderFns:[]};var S=o("VU/8")(P,E,!1,function(t){o("yzV9")},"data-v-1ad8a1ac",null).exports;n.a.use(i.a);var A=new i.a({routes:[{path:"/detail",name:"Home",component:a},{path:"/",name:"Detail",component:_},{path:"/add",name:"AddBlog",component:w},{path:"/show/:id",name:"ShowBlog",component:S}],mode:"history"}),D=o("J4Ko"),$=o.n(D),z=o("OolZ");o("991W");n.a.config.productionTip=!1,n.a.use($.a),n.a.use(z.a),n.a.filter("to-uppercase",function(t){return t.toUpperCase()}),new n.a({el:"#app",router:A,components:{App:l},template:"<App/>"})},"SZq+":function(t,e){},SgOk:function(t,e,o){var n={"./blog":"CCyo","./blog.json":"CCyo","./dapp.md":"lchl","./flex布局整理.md":"TYT/","./html+css.md":"Df8s","./js上.md":"el5o","./js下.md":"eu25","./标签分类及宽高整理.md":"mwsk","./水平居中垂直居中整理.md":"36qd","./浮动.md":"L9eU"};function r(t){return o(l(t))}function l(t){var e=n[t];if(!(e+1))throw new Error("Cannot find module '"+t+"'.");return e}r.keys=function(){return Object.keys(n)},r.resolve=l,t.exports=r,r.id="SgOk"},"TYT/":function(t,e){t.exports='<h1 id=flex布局>flex布局</h1> <p>参考视频：</p> <p>[flex属性介绍] <a href="https://www.bilibili.com/video/BV1hE411c7zz?from=search&amp;seid=13478762790239323054">https://www.bilibili.com/video/BV1hE411c7zz?from=search&amp;seid=13478762790239323054</a></p> <p>[grid栅格布局]<a href=https://www.bilibili.com/video/BV1kE411g7c8>https://www.bilibili.com/video/BV1kE411g7c8</a> </p> <p>[flex快速入门----有图便于理解]<a href=https://www.cnblogs.com/abc-x/p/11100711.html>https://www.cnblogs.com/abc-x/p/11100711.html</a></p> <p>[flex属性解析----有图便于理解]<a href=https://www.cnblogs.com/kinblog/p/11545368.html>https://www.cnblogs.com/kinblog/p/11545368.html</a></p> <p>[知乎]<a href=https://zhuanlan.zhihu.com/p/103219555>https://zhuanlan.zhihu.com/p/103219555</a></p> <h2 id=属性一览：>属性一览：</h2> <ul> <li><h4 id=基本布局（只设置一个display：flex------所以大多属性都是默认值-）>基本布局（只设置一个display：flex----- 所以大多属性都是默认值 ）</h4> <p>在父元素.container中加入<code>display:flex</code>后，子元素 会依次从左到右横向排列（默认排列方式）；</p> <p><strong>这个时候就分情况： 如果父元素的宽度（因为默认横向，所以是看宽度）是否足够放下这些子元素：</strong></p> <p>​ 足以放下他的子元素，子元素就是他们自己的宽度；（右边会有空余空间） ​ 如果不足以放下他们子元素，子元素的宽度会等比例缩小;（宽度还是宽，窄得还是窄）</p> <p>这时候如果想设置：分行显现：设置属性<code>flex-wrap:wrap</code>（默认：nowrap）</p> <p>​ 此时 每个子元素的宽度就不用随着缩小了---在父元素宽度不够的时候</p> <p> <strong>但是在多行显示中 ，如果子元素的高度 不到 400px，会出现 相邻行之间会有空白间隙；（就是说每一个flex行是有一个高度的，就是图书馆的每格书架一样 ），当超过这个400px，就没有空隙了，这个flex行的高度就是随之增大</strong></p> </li> </ul> <ul> <li><h4 id=父元素其他属性：>父元素其他属性：</h4> <ul> <li><p>flex-direction：<strong>改变主轴方向的</strong>；row默认 （column 列）</p> <blockquote> <p>justify-content 和 align-content 其实分别指的指 主轴和 副轴的方向的</p> </blockquote> </li> <li><p>justify-content : 设置靠主轴的子元素布局方式 flex-start默认</p> <p>其他属性值： flex-end center space-between（中间留空隙--空隙等宽）space-evenly（两边中间都溜空隙 ）</p> </li> </ul> </li> </ul> <hr> <p>以上样式 ，如果出现分多行现象，高度又不够一个flex行的高度时候，还是有纵向的空白间隔</p> <hr> <ul> <li><ul> <li><p>align-content：设置靠副轴的子元素布局方式，属性值和上面一样 <strong>没有默认值的</strong></p> <p>​ -------flex-start，flex-end， center*<em>可以消除 行与行之间的空白 *</em></p> </li> </ul> </li> </ul> <ul> <li><p>align-items： 控制每flex行的内部的子元素<strong>副轴</strong>上的 布局； stretch 默认值</p> <p>​ stretch：<strong>当子元素不设置高度的时候 会将子元素高度设置成每flex行的高度</strong></p> <p>​ 其他属性值 ：flex-end center space-between</p> </li> </ul> <ul> <li><h3 id=子元素属性>子元素属性</h3> <ul> <li>flex-shrink：缩小的比例值 （默认是1） flex-shrink：2---------- 缩小的比例值 （默认是1）</li> </ul> </li> </ul> <pre><code> 当 nowarp的时候一行显示不够，会压缩每个子元素得宽度；\n\n （若不想压缩某个子元素，则设置 **flex-shrink：0**）\n\n 默认比例是1时，他们是按照每个子元素的宽度进行**等比例**压缩的。宽度大的压缩得多，\n\n设置比例越大，压缩得越狠；</code></pre><ul> <li><p>flex-grow：放大的比例值 默认是0 </p> <p>当一行<strong>本来会留有空白（不设置flex-grow）</strong>的时候， 设置flex-grow的子元素 宽度会将空白的宽度并给自己宽度：数值就是比例） </p> </li> <li><p>flex-basis：设置宽度；设置每个子盒子的宽度；</p> </li> </ul> <ul> <li><p>flex ：栅格布局--------------最常用</p> <p>可以将flex-grow, flex-shrink, flex-basis进行连写。flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。 浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为flex: 0 1 auto。简写还包括：</p> <ul> <li>flex: 1; --&gt;&gt; flex: 1 1 0%; flex: none; --&gt;&gt; flex: 0 0 auto</li> <li>flex: auto; --&gt;&gt; flex: 1 1 auto; flex: 0 auto</li> <li>flex: initial --&gt;&gt; flex: 0 1 auto; 即flex的初始值</li> </ul> </li> <li><p>order：控制子盒子顺序：（本身默认是0）（0排完了排1的）相同的order值，html结构中前面的在前面</p> </li> </ul> <h1 id=栅格布局>栅格布局</h1> '},ZsQh:function(t,e){},bZrT:function(t,e){},el5o:function(t,e){t.exports="<p>静态语言（强类型语言） 静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 </p> <p>例如：C++、Java、Delphi、C#等。 动态语言（弱类型语言） 动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。</p> <p>1、script标签如果是引入外部的js文件,这个标签中不要添加内容~ 2、变量名是地址的别名 ，可以通过变量名访问变量 3、null表示空值、 可以对一个变量赋值是null，NaN 不是一个数 一般用 ！exp判断是不是空（但是不严谨）</p> <p>4、parseInt(true) ------结果 nan</p> <pre><code>隐式转换\n==是比较运算符，所有两边都是转成Number型。[ ]转成0，true转成1\n！是逻辑运算符，所以会转成Boolean，[ ]转成true,前面加！！所以还是true\n 两个不是值的值比较不可能相等</code></pre><p>进制转换：num.toString(2)；---结果是字符串</p> <p>5、if只要第一个条件满足了 后面的哪怕true也不会执行 了------好像不对</p> <p>6、break 是跳出循环 和switch的---不是跳if的 continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内</p> <p>7、//var arr1=new Array(10,80,60,50,20,30,40); //console.log(typeof arr1);/* 放回的是object<em>/ --------------------------联想原型 arr1=[10,80,60,50,20,30,40]; console.log(typeof arr1); /</em> 放回的是object*/</p> <pre><code>类型： 基本类型 number boolean null string undefined\n        引用类型  object               --------这些都是typeof会返回的值\n\n        引用类型 内部又包括 （Object Array Math RegExp Date Error  | 包装类型：Number String Boolean ）</code></pre><p>8、函数没有返回值，却调用的时候用变量接收了，那么结果就是undefined； 函数调用，如果某个参数没穿，这个值就是undefined function apt(a,b){ console.log(a+&quot;----&quot;+b) } apt(2) // 2------undefined；</p> <pre><code>另外：\nvar b=function(d,k,l){console.log(&quot;gsfg&quot;)};\n\nconsole.log(b.length)//返回形参的个数</code></pre><p>9、函数也是一种数据类型： typeof func_name； 结果是function---------------------联想原型</p> <p>10、函数表达式： var f1=function (){ console.log(&quot;dfasdf&quot;); }； f1();//函数调用； 这里的函数调用可以 这样理解：f1相当于是变量 赋值的值是函数代码 加上（） 就是调用 //（<strong><strong>*****</strong></strong>）本身函数调用实质 就是 函数代码+（）；</p> <p>（<strong>*****</strong>）如何定义一个动态函数名的函数：</p> <p> var funcname=“fasdasd”； window[funcname]=function(){}</p> <p>11、声明的变量是var声明的，那么这个变量就是全局变量；全局变量就可以在页面任何位置使用； 除了在函数以外，其他的任何位置定义的变量都是全局变量； 全局变量 是可以跨script标签使用的 --------（<strong><strong><strong>**</strong></strong></strong>）很厉害呀</p> <p>局部变量：在函数内部的定义的变量，是局部变量；只能在函数内部被调用；函数调用结束之后 内存就释放；也是var调用的</p> <pre><code>  函数内部用的不是局部变量的话  结束就不会被释放；\n函数内部调用的值；若本层中没有定义该局部变量，会去看看它的上一级 有没有同名的变量存在\n      如果有的话，会去调用这个；一次从里向外找；</code></pre><p>12、作用域链： 在一个函数中使用一个变量，先在该函数中搜索这个变量，找到了则使用，找不到则继续 向外面找这个变量，找到则使用，一直找到全局作用域，找不到则是undefined；</p> <p>13、预解析： 变量声明 var n 和 函数声明 function（）{console.log(&quot;...&quot;)}都会提前到当前作用域的最上方 所以函数声明在前在后 不影响调用执行 另外 script的标签内的也是一个作用域 只能提前到当前的script标签内部上方</p> <p>函数提升大于变量提升，变量提升会提升到除函数声明的后面；</p> <p>14、对象： new Object（） 字面量方式 自定义构造函数 通过自定义构造函数定义的 下面的结果是true（****-------------------------------------------------联想原型 先了解 ） console.log(obj instanceof Person) 放回true instanceof 表示 是引用类型的变量 obj instanceof Person ---前面是变量 后面是构造函数的名字（书上叫引用类型） Person 叫一种引用类型</p> <p>15、访问对象的两种方式： 点访问和[]访问；</p> <p>对于点访问 无论属性的键 带不带双引号，在访问时候加不了双引号；（可以访问带双引号的键值）</p> <p>对于[]访问 访问属性的时候，不管属性的键带不带双引号，则访问的都要带双引号（此时引号不能省），----在控制台上面测试的</p> <p>16、遍历对象 for (var key in json){}</p> <p>17、11-5-4 是很重要的一节 ----------------自己懂了 主要介绍两点： 基本类型值和引用类型 解析器会做不同处理 在 复制变量值 和 函数传递参数的时候 会有区别 -----对象中存入的是地址 函数传递也是传值 所以 函数内部操作属性方法 会改变外面的对象的 结构</p> <pre><code>对象中也是这样存储的；  4-28   见 11-5-4   有测试里：\n      objtest={a:&quot;123&quot;,b:[1,2,3],c:{&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;2&quot;},func:function(a,b){return a+b}}\n        var k1=objtest.a;\n        k1=&quot;234&quot;;\n        console.log(objtest);  //原对象没有改变\n        var a1=objtest.b;\n        a1[2]=7;\n        console.log(objtest);   //原对象改变了； 因为传递的是地址\n        console.log(a1[2]);\n        a1=[6,7,8];\n        console.log(objtest);\n        console.log(a1);</code></pre><p>18、静态对象（不需要实例化对象 直接调用） 和 实例对象（实例化以后 对实例进行调用） 实例方法----必须通过new的方式创建的对象（实例对象）来调用方法； 静态方法----直接通过大写的构造函数的名字调用的方法 如：String.fromCharCode()</p> <p>19、string 和String对象 普通的string是没有方法的 在调用方法的时候 会去先包装成String对象 在调用方法</p> <p> 字符串的不可变性：var string=&quot;hello&quot;; string[1]=&quot;w&quot; //这个是不可以操作的； --------记住就好 可能和语言底层设计有关； 字符串可以遍历；</p> <p>20 如何判断一个对象属性和方法是不是存在的 if（obj[name]）{}</p> <p>21、常见内置对象的方法： Math.ceil(Math.random()*5) 生成 0-5的方法 也可以用parseInt（） 字符串： 1、str.indexOf(&quot;xiadasdo&quot;,5); 从下标5开始找 ，没找到返回-1；----通常用于判断是否拥有某个字符串 2、str.match(); ---正则表达式（replace也只支持正则表达式）</p> <p>-------这是一个不改变自身实例的一个方法------------ 3、str=str.replace(str1，str2) 替换值 在str中 把str1 换成str2 但是 str没有改变 要用一个返回值接住 再用str 就是的到改变后的了 例子： var str1=&quot;起码的是五分豪情&quot;; str2=str1.replace(&quot;五分&quot;,&quot;十分&quot;); console.log(str1); //起码的是五分豪情 console.log(str2); //起码的是十分豪情</p> <pre><code>    4、str.slice(start,end)  ---截取切片；没有end   返回的是截取后的片段  依然不改变原有实例；\n    5、str.concat()\n    6、str.split(&quot;&quot;)  返回数组\n    7、substring(start，end)  也是切字符串  （） （****于slice的区别是）  substring() 不接受负的参数。\n\n   8.match() ---查找字符串\n            var str = &quot;今天天气好好&quot;;\n            var result = str.match(&quot;天天&quot;);\n             console.log(result);//[&quot;天天&quot;, index: 1, input: &quot;今天天气好好&quot;, groups: undefined]\n   9.search()-----查找字符串返回下标\nvar str = &quot;今天天气天天好好&quot;;\n        var result = str.search(&quot;天天&quot;);\n        console.log(result);//1\n\n  10、includes--检测是否包含指定字符串\n\n\n 数组方法：\n    arr.every(function（ele,index，arr本身）) 用来测试数组的每个元素；返回布尔类型 (如果所有的元素都复合条件，才返回true)\n\n    arr.filter(func),  返回数组中每一个元素都复合条件的元素，组成了一个新的数组</code></pre><p>---------这几种方法 调用就会改变调用它们的对象 arr直接变---------叫变异方法： .push(val): 在数组后面追加一个val； 返回值是追加的值 .pop(): 删除最后一个元素；返回值是删除的值 .shift(): 删除数组中的第一个元素； 返回值是删除的值 .unshift(): 向数组的第一个元素前面插入一个新的元素 .sort() 但是排序不稳定 （sort中也可以传函数，写固定的函数就稳定了） 函数的写法也有讲究：return 1 0 -1； //形参的a,b 相当于以前 a[j],a[j+1]</p> <pre><code>     .splice(index,要删除的个数,val)  //返回的是 切的以后的值  在index后面添加val    ，一般是用于删除数组中的元素；\n                          或是替换元素，或是插入元素；\n            .splice(index,1)------删除index元素；，index也算；  -------只删除不替换\n\n     关于数组方法splice用法：\n\n        splice（1，0，&#39;Tom&#39;）：表示在索引为1的元素前面（注意是前面插入）插入元素’Tom‘（也可以理解为从索引为1的元素开始\n        删除，删除0个元素，再在索引为1的元素前面添加元素&#39;Tom&#39;）；\n\n        splice（1，1，&#39;Tom&#39;）：表示从索引为1的元素开始删除（包括索引为1的元素），共删除1个元素，并添加\n        元素&#39;Tom&#39;。即把索引为1的元素替换为元素&#39;Tom&#39;。</code></pre><hr> <p>-------这是一个不改变自身实例的一个方法------------</p> <pre><code>    .slice(firstindex，lastindex)  // 切一部分返回一个数组，不包含结束的索引\n.slice(0)   就是不切返回（相当于克隆一个新的）\n    高手代码里看到.slice(0)，查了下这样写的好处：\n1.对原数组进行深拷贝，这样进行一系列操作的时候就不影响原数组了；\n\n2.将类数组对象转化为真正的数组对象：var anchorArray = [].slice.call(document.getElementsByTagName(‘a’), 0); \n\n   arr1.concat(arr2) -----------组合数组 不改变arr1 和arr2\n\n    .foreach(func):  遍历数组  相当于for循环 -----内置的回调函数 可以实现对每一个元素操作\n            var arr=[10,20,30];\n            arr.forEach(function (ele,index) {\n                console.log(ele+&quot;===&quot;+index)\n            });\n\n    arr.indexOf(val):  //返回的是索引，没有就是-1；\n\n    .join(&quot;|&quot;)   //  返回字符串；\n\n    .map(func):  数组中的所有元素都要执行一次这个方法~ ,把执行后的结果重新放在一个新的数组中；</code></pre><p>总结： 这些方法 有的会对调用实例 产生改变 ，有的不会 ，有的因为功能在于 其返回值 一个不关心调用实例是否变化，一个也肯定不会变化</p> <pre><code>    主要在意那些会对调用实例 改变的方法  数组中的有 splice push pop shift unshift（插入） sort\n                                           字符串中目前没有</code></pre><p>22、基本包装类型： 本身是基本类型；但在执行代码过程中，如果这个类型的变量调用了属性或者是方法 那么这种类型就不再是基本类型了，而实基本包装类型，这个变量也不是普通的变量了，而实基本包装类型对象；</p> <pre><code>var num=10;\nconsole.log(num.toString())\nconsole.log(typeof num)---------还是number  可能是应该 该方法 不会对调用实例做改变？？  这和语言的设计有关</code></pre><p>JS 中值的类型分为原始值类型和对象类型。原始值类型包括 number, string, boolean, null 和 undefined；对象类型即 object。首先原始值类型它就不是对象。 另外，要注意 &#39;hello&#39; 和 new String(&#39;hello&#39;) 的区别，前者是字符串字面值，属于原始类型，而后者是对象。用 typeof 运算符返回的值也是完全不一样的： 1 2 typeof &#39;hello&#39;; // &#39;string&#39; typeof new String(&#39;hello&#39;); // &#39;object&#39; 之所以很多人分不清字符串字面值和 String 对象，归根结底就是 JS 的语法对你们太过纵容了。当执行 &#39;hello&#39;.length 时，发现可以意料之中的返回 5， 你们就觉得 &#39;hello&#39; 就是 String 对象，不然它怎么会有 String 对象的属性。 其实，这是由于 JS 在执行到这条语句的时候，内部将 &#39;hello&#39; 包装成了一个 String 对象，执行完后，再把这个对象丢弃了， 这种语法叫做 “装箱”，在其他面向对象语言里也有（如 C#）。不要认为 JS 帮你装箱了，你就可以在写代码的时候不分箱里箱外了</p> <p>js的单线程环境、定时器运行---<a href=https://blog.csdn.net/Febby_/article/details/94763441>https://blog.csdn.net/Febby_/article/details/94763441</a> 在所有同步任务执行完之前，任何的异步任务是不会执行的</p> <p>//console.log(parseInt(true))// 结果是NaN 因为 （会先默认转成字符串 ---所以是nan）</p> <pre><code> //if 判断 true了后  后面的不会执行\n// var num1=10;\n//  if(num1&gt;5){\n//      console.log(&quot;dayu &quot;)\n//  }else if(num1&gt;6){\n//      console.log(&quot;fasdfasd&quot;)\n//  }</code></pre><p> //预解析的例子 // function f1() { // console.log(num);//undefined // var num=10; // } // f1(); // console.log(num);// 报错</p> <p> // 跨script标签的预解析： // var num=10; function f1() { console.log(&quot;哈哈&quot;); } f1() console.log(num)</p> <p>----/script ----script----</p> <pre><code>  var  num=10;\nf1();\nfunction f1() {\n  console.log(&quot;嘎嘎&quot;);\n}\nconsole.log(num)</code></pre>"},eu25:function(t,e){t.exports='<p>1、对象： -------（所以一般对象 指的是实例化以后的）</p> <p>2、对象中的属性是 基本类型的怎么存储？？？？</p> <p>3、console.dir(per)的结果是 其构造函数定义的属性和方法（是赋值之后的）+<em>proto</em>(里面有一个constructor和<em>proto</em>) console.dir(Person)的结果 构造函数内容 + prototype+ <strong>proto</strong>（函数自己的原型Function.prototype）</p> <p> 本来是 console.log(per.<strong>proto</strong>.constructor==Person);===》规定这样console.log(per.constructor==Person);// true 虽然per并没有这个constructor属性的；</p> <p>注：console.dir(Person) 的结果 里面的Person.prototype.constructor 也有自己的构造函数： --------------------注意</p> <p> 关系可以在三者关系的图中反应出来；</p> <p>实例对象dir后 会显示 定义的属性和方法（是赋值之后的） 构造函数内容中 并没有这些属性和方法 （没有 age和name 等）</p> <p>4、进一步通过原型解释实例对象和 构造函数的结构</p> <pre><code>* 构造函数可以实例化对象\n* 构造函数中有一个属性叫prototype,是构造函数的原型对象\n* 构造函数的原型对象(prototype)中有一个constructor构造器,这个构造器指向的就是原型对象所在的构造函数\n* 实例对象的原型对象(__proto__)指向的是该构造函数的原型对象\n* 构造函数的原型对象(prototype)中的方法是可以被实例对象直接访问的（*******）</code></pre><p>通过原型添加的方法 可以实现数据共享 这个方法也只有在实例对象的原型中可以找到，实例对象可以用其原型的方法</p> <pre><code>* 构造函数的原型对象(prototype)中有一个constructor构造器,这个构造器指向的就是该原型对象所在的构造函数</code></pre><p>（因为原型对象是在构造函数结构 内部的 构造函数.prototype ）</p> <p>另外： //实例对象的原型<strong>proto</strong>指向的是该对象所在的构造函数的原型对象 //构造函数的原型对象(prototype)指向如果改变了,实例对象的原型(<strong>proto</strong>)指向也会发生改变</p> <p>5、原型的第一个作用就是共享数据 ---节约资源 简单写法中需要手动指定构造器的指向 constructor:Student,</p> <p>6、原型中的方法,是可以相互访问的</p> <pre><code>背景： //实例对象的方法,是可以相互调用的\n   而 原型中的方法也是可以相互访问的：（在调用eat（）中调用play）</code></pre><p>7、实例对象使用的属性或者方法,先在实例中查找, 找到了则直接使用,找不到则,去实例对象的<strong>proto</strong>指向的</p> <p>8、局部变量变成全局变量： 把这个局部变量给 window 就可以全局用了 （用到自调用函数 ---window参数是可以不加的 ）</p> <pre><code>这里面应用了js语法中的两点：\n      一、通过函数参数，对象局部修改可以修改，可以实现全局修改；----传入的是一个对象\n      二、window是一个特殊的全局对象 ，window可以省略；  ------直接是num\n\n      //把局部变量给window就可以了\n  (function () {\n    var num=10;//局部变量\n    //js是一门动态类型的语言,对象没有属性,点了就有了\n    window.num=num;\n  })();\n  console.log(num);</code></pre><p>9、原型链 以及原型的最终指向： 一个原型对象 也是有原型的（这时候 可以看成原型对象是一个 实例对象）， 举例： new Person（） 是通过Person()构造函数实例化出来的 new Person() 是一个实例对象，其原型对象 是Person.prototype ,（person.<strong>proto</strong> 指向 同Person.prototype） 原型对象 也是一个对象 （可以认为它是 new Object 出来的实例对象 所以） 它的原型是 object.prototype</p> <pre><code>（下一级原型相对 上一级 就像是一个实例对象 ）</code></pre><p>10、原型的指向可以改变； ------继承中会用到 Student.prototype=new Person(10); 这里面new Person(10)实例对象（它指向自己的原型对象）就是student的原型对象 （原型链的层又多了一层了<strong><strong>*****</strong></strong>）</p> <p>11、继承--- 组合继承:原型继承+借用构造函数继承（call） function Person(name,age,sex) { this.name=name; this.age=age; this.sex=sex; }</p> <pre><code>      Person.prototype.sayHi=function () {\n        console.log(&quot;阿涅哈斯诶呦&quot;);\n      };\n\n      function Student(name,age,sex,score) {\n        //借用构造函数:属性值重复的问题\n        Person.call(this,name,age,sex);\n        this.score=score;\n      }</code></pre><p>12、this指什么： 普通函数中的this是谁?-----window * 对象.方法中的this是谁?----当前的实例对象 * 定时器方法中的this是谁?----window 定时器是window的方法,相当于window.setInterval， * 构造函数中的this是谁?-----实例对象 * 原型对象方法中的this是谁?---实例对象</p> <p>13、apply和call和blind的使用 只要是想使用别的对象的方法,并且希望这个方法是当前对象的, 那么就可以使用apply或者是call的方法改变this的指向 （也有函数调用的功能）</p> <pre><code>func.apply(对象,[参数1,参数2,...]) 后面的参数是给func的形参  改成 函数是这个传入对象的方法</code></pre><p> //牛客网：---使用闭包 实现函数 makeClosures，调用之后满足如下条件： 1、返回一个函数数组 result，长度与 arr 相同 2、运行 result 中第 i 个函数，即 result<a href="">i</a>，结果与 fn(arr[i]) 相同 //function makeClosures(arr, fn) { // var result=[]; // for(var i=0;i&lt;arr.length;i++){ // result[i]=function(){ // return fn(arr[i]); // } // } // return result //} ---这种写法i是等到执行的时候 i是arr.length;因为闭包中的变量不释放；</p> <pre><code>function makeClosures(arr, fn) {\n    var result=[];\n    for(var i=0;i&lt;arr.length;i++){\n        result[i]=fn.bind(null,arr[i])//  写成fn 没有参数 ，写成fn（arr[i]）是一个调用（***************）\n    }\n    return result\n}</code></pre><p>14、函数作为返回值使用： 个人感觉，1、使用函数作为返回值，可以增加一个函数的参数的的方法： 适用在不方便给函数添加形参的时候，就像arr中的sort方法中的形参函数；他只能传数组中的两个值；</p> <pre><code>      2、 后面结合闭包使用 可以达到缓存值得用法；</code></pre><p>15、闭包：（函数A内部有一个函数B ，函数B用了函数A中的参数） 结合函数作为返回值 （返回的函数就是函数B，形成闭包） 函数作为返回值 ，可以做到 缓存数据功能 三次调用生成同一个随机数 （缓存数据）</p> <p> ----闭包中的变量不会被回收；</p> <p>16、沙箱： (function(){}) 沙箱内部发生的事情并不影响外界的变量； 就像是 一个函数内部</p> <pre><code>沙箱解决了 变量名和函数名冲突的问题，</code></pre><p>17、深拷贝和浅拷贝：----还是得靠百度；</p> <p>18、正则表达式</p> '},lchl:function(t,e){t.exports="<h1 id=最小必要知识（后面跟一个空格）>最小必要知识（#后面跟一个空格）</h1> <blockquote> <p> 提到 通过某一个节点作为入口 ----和自己的理解似乎一致</p> <p>称智能合约为：被代码控制的账户</p> </blockquote> <blockquote> <p>智能合约每部署一次 ，产生的实例都是不同的，一个完全不同的账户；</p> </blockquote> <h1 id=开发环境准备>开发环境准备</h1> <h3 id=必要条件1：测试网络节点>必要条件1：测试网络节点</h3> <blockquote> <blockquote> <p>解决办法： 自己搭建私有区块链： 实施成本搞</p> </blockquote> </blockquote> <blockquote> <blockquote> <p> 或者 用Ganache/remix （成本低，本地测试方便，内置就已经解锁账户）</p> <p>或者用共享测试网络： 网络入口节点 infura.io ---------需要有自己的钱包和账户</p> </blockquote> </blockquote> <h3 id=必要条件2：账户和余额>必要条件2：账户和余额</h3> <blockquote> <blockquote> <p>解决办法：使用metamask钱包</p> </blockquote> </blockquote> <h1 id=智能合约工作流---后端>智能合约工作流---后端</h1> <blockquote> <blockquote> <p>在线IDE remix 测试（可以好好的测试调试）</p> </blockquote> </blockquote> <blockquote> <blockquote> <p>vscode+nodejs</p> <p>介绍 彩票原型（是有构造函数的） 用到一个modier函数 ：确保必须得是 合约创建者才能调用</p> </blockquote> <p>通过nodejs部署测试；---组件后端完成（用node进行部署和测试）</p> </blockquote> <h2 id=dapp构建和部署>Dapp构建和部署</h2> "},mwsk:function(t,e){t.exports="<h1 id=标签的分类：>标签的分类：</h1> <ul> <li><p>块级元素（<strong>独自站一行 可以设置宽高 对齐属性</strong>）</p> <pre><code>     如：`h1 ` `p ` `div` `ul` ` ol ` `li`</code></pre><p>​ 特点：<strong>默认的宽是100%</strong>；</p> </li> </ul> <p>​ 自动换行（一行只放一个 不管宽度多少） ​<br> ​ 可以容纳内联元素和其他块元素</p> <ul> <li><p>行内元素 （<strong>内容撑开页面，不可以设置宽高</strong>）</p> <pre><code>     如 `a` `strong` `em` `b` `i` `del` `s` `span`等</code></pre><p>​ 特点：不占独立的区域； 仅仅依靠自身的字体大小和图片支撑结构</p> <p>​ <strong>不可以设置宽度， 高度 ，对齐属性（text-align 因为宽没用了也没用了，不支持上下margin）；</strong></p> </li> </ul> <p>​ <strong>默认的宽度就是他自身的内容的宽度</strong>； ​<br> ​ 元素内部换行符号 解析成空格</p> <pre><code>   ​                行内元素只能容纳文本或者其他行内元素 （a特殊）    </code></pre><ul> <li><p>行内块元素（<code>inline-block</code>可以设置宽高）</p> <p>​ 如： <code>img</code> <code>input</code> <code>td</code></p> <p>​ 特点： 和相邻的行内元素（行内块）在一行上 但是之间会有白色空隙；</p> <p>​ <strong>默认宽度就是它本身内容宽度</strong></p> <p>​ 元素内部换行符号 解析成空格</p> <p>​ 高度行高 外边距和内边距都可以控制；</p> </li> </ul> <p><strong>a标签 span行内元素 也是不会被图片撑开 ； 宽度是 图片的宽度， 但是高度还是自己的很多时候，适当时需要变化成块级元素</strong></p> <p>注：</p> <blockquote> <ol> <li>行内元素与块级元素的区别之一：</li> </ol> <p>​ 对于行内元素来说margin只有margin-left和margin-right有效，padding只有padding-left和padding-right有效</p> <ol start=2> <li><p>行内块元素和内容有关系的； 如果没有内容 又没有设置宽或者高 就是空的；</p> </li> <li><p>行内元素和行内块元素 的宽度 内容多少就是多少，内容为空就是0</p> </li> </ol> <ol start=4> <li>虽然块级元素内部可以放 块级元素和行内元素以及行内块元素；但是 对于p和 h1标签而言 文字才能组成段落 ，所以在p标签和 h1 标签中也一般不装块级元素</li> </ol> <ol start=5> <li>虽然行内元素只能容纳文本或者其他行内元素，但是a特殊 是可以放块级元素的-----一般页面logo的设计<pre><code>   （a放块级元素的时候是不是将自己变成行内块元素或者是块级元素）</code></pre></li> </ol> </blockquote> <p>补充：<strong>块级元素 内部文字水平居中</strong></p> <p>​ <strong><em>而且：行内元素和行内块元素可以看成是文本 可以使用text-align居中对齐；</em></strong></p> <h1 id=宽高默认值整理：>宽高默认值整理：</h1> <ul> <li><p>宽度width：摘自：<a href=https://blog.csdn.net/weixin_41030302/article/details/103180436>https://blog.csdn.net/weixin_41030302/article/details/103180436</a></p> <p>首先，明确一点： <code>HTML</code> 元素属性 <code>width</code> 的默认值是 <code>auto</code> </p> <p><code>auto</code>的四种表现：</p> <ul> <li>fill-available —— 意为 充分利用可用空间，比如块级元素 div 的宽度默认为父级元素的 100% ，这种表现也被称为块级元素的流动性。</li> <li>shrink-to-fit —— 意为 收缩至合适，比如 <code>inline-block</code> 元素</li> <li>min-content —— 意为 收缩至最小，在古老的表格布局中会出现（擎天柱的效果）。</li> <li>max-content —— 意为 超出容器限制。</li> </ul> </li> </ul> <p> <strong>正是由于 <code>auto</code> 有四种表现，从而造成了不同的元素的默认宽度有不同的表现。</strong></p> <ul> <li><p>块级元素：默认值auto，表现为父元素的100%</p> </li> <li><p>行内块元素以及行内： 表现为内容宽度；</p> </li> </ul> <p>width设置100%：是其父元素的百分比；</p> <p>所以对于块级元素，如果想设置子元素宽度和父元素相等 , 可以不用写，默认就是这个</p> <p>​ 高度不行，必须要设置<code>height:100%</code></p> <p><strong>当这个父元素是body的时候，该元素就会随着 浏览器宽度变化而变化了</strong></p> <ul> <li><p>高度height：摘自：<a href=https://segmentfault.com/a/1190000020247492>https://segmentfault.com/a/1190000020247492</a></p> <p>明确<strong>高是不能继承的</strong></p> <p>高的默认值：<strong>高度是由子元素来决定的</strong></p> </li> </ul> <p>一个元素的height：</p> <p>​ ①可以不设置（默认）</p> <p>​ ②可以设置百分比</p> <p>​ ③设置固定的px的高度</p> <p>​ ④可以设置auto</p> <p>总结：</p> <ul> <li><p>如果不设置，那么他的高度是由子元素来决定的</p> </li> <li><p>如果设置成auto，和不设置是一样的，那么他的高度是由子元素来决定的</p> </li> <li><p>如果设置成百分比，那么他的高度是由父元素来决定的</p> <blockquote> <p> <strong>给一个元素的height设置%的前提是该元素的父级的高度是确定的</strong></p> <p>​ 这种确定：包括 爷爷是固定高度，父级元素设置%，（这时候父级元素也算高度确定）</p> <p>​ 此时子级元素 设置% 还是有效；</p> <p>​ 但是 如果从body后所有级别都设置百分比就不行了</p> <p><strong>要想设置子元素高度和父元素高度相等</strong></p> <p>​ 因为没有默认了：所以必须要写<code>height：100%</code></p> </blockquote> </li> </ul> <ul> <li>如果设置成固定的px,那么就是他自己来决定的</li> </ul> "},nP45:function(module,__webpack_exports__,__webpack_require__){"use strict";var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__=__webpack_require__("BO1k"),__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default=__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator__),__WEBPACK_IMPORTED_MODULE_1__static_dapp_md__=__webpack_require__("lchl"),__WEBPACK_IMPORTED_MODULE_1__static_dapp_md___default=__webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__static_dapp_md__);__webpack_exports__.a={name:"detail-content",data:function(){return{Blogs:[],Categories:[{catename:"html+css",catenum:5},{catename:"js",catenum:2},{catename:"webapi",catenum:1},{catename:"vue",catenum:2},{catename:"node",catenum:1},{catename:"后端ajax",catenum:1},{catename:"es6接触",catenum:1}],search:""}},computed:{filterBlogs:function filterBlogs(){var _this=this;return this.Blogs.filter(function(blog){var reg=eval("/"+_this.search+"/gi");return blog.title.match(reg)})}},created:function(){this.$http.get("../../../../static/blog.json").then(function(t){var e=t.body.bloglists,o=!0,n=!1,r=void 0;try{for(var l,i=__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_get_iterator___default()(e);!(o=(l=i.next()).done);o=!0){var s=l.value;this.Blogs.push(s)}}catch(t){n=!0,r=t}finally{try{!o&&i.return&&i.return()}finally{if(n)throw r}}console.log(this.Blogs)})}}},o3KR:function(t,e){},s6Wf:function(t,e){},t8xF:function(t,e){},tTbG:function(t,e){},vV80:function(t,e){},yzV9:function(t,e){}},["NHnr"]);
//# sourceMappingURL=app.f0a12800decf9fe8bed5.js.map