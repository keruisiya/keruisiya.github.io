# `JS`高级语法整理

+ 内容包括：（持续更新吧）
  + 原型+原型链与继承
  + apply，call函数应用+ this讲解
  + 局部变量变全局变量
  + 闭包与沙箱
  + 深拷贝与浅拷贝
  + 正则表达式

# 后知后觉

ps：一个对象属性在堆空间是怎么存储的（基本类型和引用类型按照）

​	对象属性是个对象的时候 还是存储的是地址（在一个新的堆空间中再开辟一个空间存储），是基本类型的时候还是存储的是值。



---------------------------





## 原型+原型链和继承

-------见子文档哦~



### apply和call函数调用与this讲解

+ this的理解：

  常见this的指向：

   	普通函数中的this是谁?-----window

   	对象.方法中的this是谁?----当前的实例对象

   	定时器方法中的this是谁?----window

  ​	 		定时器是window的方法,相当于window.setInterval，

  ​	 构造函数中的this是谁?-----实例对象

  ​	 原型对象方法中的this是谁?---实例对象

  

+ **apply和call介绍：**------可以改变this的指向；

  只要是想使用别的对象的方法,并且希望这个方法是当前对象的, 那么就可以使用apply或者是call的方法改变this的指向 **（调用了该方法 函数就会被调用）**
  
  + apply方法：----也是执行函数；
  
    `func.apply(obj,[arg1,arg2,...])` 后面数组是给func的形参  **把改成 函数是这个传入对象的方法**
  
    使用场景： ①使用apply调用一个函数。  `  f1.apply(null,[10,20])`
  
    ```
    	//使用apply方法 执行 一个普通函数
    	function f1(x,y){
         console.log("dfasdfad"+(x+y)+this);
    	}
    	f1(10,20);
    	f1.apply();     ------不需要传参这样用
    	f1.apply(null);  ------不需要传参这样用
        f1.apply([10,20]);//这样是不对的  它会把[10,20]看成是 一个对象的(是一个数组嘛，也是对象)
        f1.apply(null,[10,20]); -----不需要传参这样用
    ```
  
    ​	②apply改变**调用者this的指向**；用别的对象方法或者函数的方法
  
    ```
    	 per.sayHi.apply(stu,[10,20]); 
    	 func.apply(obj,[1,2])   -----普通func的this指向的是window
    ```
  
  
  
  + call方法和 apply方法 就只是调用方法不同而已：
  
    ​			`func.call(obj,arg1,arg2,...)`
  
  + bind方法：---------复制一个函数或者方法，**不调用**
  
    ​          `func.bind(obj,arg1,arg2,...)`
  
    ```
    	var ff=per.play.bind(stu,10,20);
    	ff();       ----调用的时候  就不需要传参数了  ，，，在bind的时候传了参数
    ```
  
  ----
  
  **调用了上述的方法，并不是 参数  obj中就具有这些方法了  ；；；；**
  
  
  
+ apply和call实操总结：

  ​	1、将**类数组对象**转化为真正的数组对象：
  
  		 anchorArray =[].slice.call(document.getElementsByTagName(‘a’), 0)
  



### 局部变量变全局变量

​    把这个局部变量给 window 就可以全局用了  （用到自调用函数 ---window参数是可以不加的 ）

​	这里面应用了js语法中的两点：
 			 一、通过函数参数（也可以不加这个window参数），

​						对象局部修改，可以实现全局修改；----传入的是window对象

 			 二、window是一个特殊的全局对象 ，window可以省略；  ------直接是num

    		//把局部变量给window就可以了
      		(function () {
        		var num=10;//局部变量
        		//js是一门动态类型的语言,对象没有属性,点了就有了
        		window.num=num;
      		})();
     		console.log(num);



### 闭包的理解和沙箱

+ 函数作为返回值

  个人感觉，函数作为返回值使用有两种用途：

​		1、使用函数作为返回值，可以增加一个函数的参数的的方法：
​               适用在不方便给函数添加形参的时候，就像arr中的sort方法中的形参函数；他只能传数组中的两个值；

​		2、后面结合闭包使用 可以达到缓存值得用法；

+ 闭包的理解：---------见子文档；

  闭包：（函数A内部有一个函数B ，函数B用了函数A中的参数）
     结合函数作为返回值 （返回的函数就是函数B，形成闭包）
     函数作为返回值 ，可以**做到  缓存数据功能**

    **闭包中的变量不会被回收；**

  案例： 三次调用生成同一个随机数  （缓存数据）



### 正则表达式





### 深拷贝与前拷贝





## 沙箱


  `  (function(){})  `沙箱内部发生的事情并不影响外界的变量； 就像是 一个函数内部

​	沙箱解决了 变量名和函数名冲突的问题，








