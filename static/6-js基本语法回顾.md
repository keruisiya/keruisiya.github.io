### 语言的分类介绍

+ 静态语言（强类型语言）

  ​		静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须**声明数据类型**。 例如：C++、Java、Delphi、C#等。

+ 动态语言（弱类型语言）

  ​		动态语言是在运行时确定数据类型的语言。**变量使用之前不需要类型声明**，通常变量的类型是被赋值的那个值的类型。 例如`PHP`/`ASP`/`Ruby`/`Python`/`Perl`/`ABAP`/`SQL`/`JavaScript`/`Unix Shell`等等。



**js是一门基于对象的语言：万物皆对象；可以模拟 js中没有继承，没有类这个概念**



**js是一门解释性语言、脚本语言、弱类型语言（声明变量用 var）  基于对象的语言
            也是一门动态类型的语言
            解释：1、 代码（变量）  只有当执行到这个位置的时候，才知道这个变量到底存储的是什么；
                				如果是对象就有对象的属性和方法，如果是变量，就是变量的作用
               		 2、对象没有什么，只有点了 通过点语法，就可以为对象添加属性和方法；**



---



# `Javascript`基础语法

+ 内容包括：基础的一些语法（个人觉得需要多回顾的点，整理如下）
  + 显示变换与隐式变换
  + 基本类型、引用类型与基本包装类型
  + 全局变量、局部变量，作用域链以及预解析
  + 内置对象（Object，Math，Array，String）常见方法的整理
  + js单线程机制



### 后知后觉

+ **==是比较运算符，所有两边都是转成Number型。**
+ **！是逻辑运算符，所以会转成Boolean**
+  函数参数未传而使用时，这个参数在执行过程中是undefined（函数的形参，相当于是声明，传参的过程是赋值）



-------------------------------------



1. 使用`javascript`

   + 浏览器控制台

   + script标签内部嵌入代码

   + script标签导入代码

     > **script标签如果是引入外部的js文件,这个标签中不要添加内容~**
     >
     > **script标签中若有错误的代码,那么该错误的代码后面的js代码不会执行;**
     >
     > **如果script标签中有错误,不会影响后面的script标签中的js代码的执行;**
     >
     > **多个script标签中的代码是顺序执行的**
     >
     > ****



2. 变量名是地址的别名 ，可以通过变量名访问变量

3. 类型以及运算符介绍：

   `number`，`boolean`，`string`，`undefined`，`null`，`array`，`object`

   **undefined 和null比较特殊**

   ```
   null（空类型，值只有一个 也是null，表示一个**尚未存在的对象**----空对象指针）
   undefined（**声明未赋值加  函数无明确返回值，函数参数未传而使用**，结果是undefined）
   ```

   ​             **一般用 if(!exp) 判断是不是空      （但是不严谨）**

   

   **NaN**:是number中一个特殊的数值；不是一个数. num/0，			

   > 得到NaN的一种常见情况：一个undefined+数字=====得到NAN;
   >
   >  **不能通过**NaN验证是不是NaN:
   >
   > ```
   >         验证这个结果是不是NaN 用isNaN(变量名或值);
   > ```

   

   **typeof**：检测数据类型常用的内置方法 **返回的结果是一个小写的字符串**

   > **typeof null------------------------------object**
   >
   > **typeof  [1,2,3]**----------------------object;
   >
   > typeof func----------------------function;

​		

​		**进制的表示**：

​			var=0x  十六进制         var num=012 默认推成8进制；

​            console.log(num) ；** 输出的结果还是以10进制表示；输出成对应的10进制数值**

​		   ***要想的得到进制：***

​			            num.toString(2)；**结果是字符串**

​		

4. **显示变换和隐式变换** -----见整理文件

+ 隐式变换：

  在JS中有一些操作符或者语句也会进行数据转换。比如if语句将条件转换为布尔类型值，

  ==是比较运算符，所有两边都是转成Number型，！是逻辑运算符，所以会转成Boolean，

  

+ 显示变换：

  Number、parseInt、parseFloat，String，Boolean



>   parseInt(true)  ------结果 nan  ----parseInt 规则 先将 参数隐式转成字符串，再转成 整数；





5. ​    **break 是跳出循环的for while 和switch的---不是跳if的**

   ​	**continue语句只能用在while语句、do/while语句、for语句、或者for/in语句的循环体内**



6. 基本类型和引用类型（object）：

   + 数据类型分类：  基本类型 `number` `boolean` `null` `string` `undefined`
        					      **引用类型  object **

     ​       					引用类型中又会包括 （`Object` `Array` `Math` `RegExp` `Date` `Error`）

​				                          可以通过： **instanceof**获取具体的引用类型

​						示例：


    		 console.log(obj instanceof Person)  返回true
    		 instanceof表示是引用类型的变量
    		 obj instanceof Person---前面是变量，后面是构造函数的名字（书上叫引用类型）  



+ + 复制变量值** 和**函数传递参数**的时候  引用类型和基本类型的区别（非常重要）

  基本类型值和引用类型在复制变量值 和 函数传递参数的时候 ， 解析器会做不同处理；

  引用类型中存入的是地址，基本数据类型存入的数值

  **所以在复制变量值的时候， obj1=obj2  和 a=b 就会不同了**

  obj2改变属性和方法的时候，obj1也会改变（反之也是），但b变化，a是没有变化的

  **函数传递也是传值**  所以函数内部操作属性方法  会改变外面的对象的结构

----

注意： 上序的情况是 obj2（其中一个对象）改变属性和方法，但是如果 完整改变 ，将obj2=obj3；此后 obj1和obj2 就没有关联了，obj2的改变不会引起obj1的变化；



> **上序概念一定要结合栈内存和堆内存进行理解**



7. 函数的相关介绍：

+ 函数的定义方式：

  + 两种：一种是**函数声明**，一种是**函数表达式。**

  关于函数表达式的理解：

  首先明确函数调用的实质：  **函数代码+（）**

  对于函数声明的形式：

  	 		function  test(a,b){   //函数声明以后，console.log(test) 结果是函数代码
  	 			var c=a+b;
  	 			return c;
  	 		}；
  		 	test(2,3) ；-----  所以是 函数代码 +（）
  对于函数表达式：

  			var test= function (a,b){   //函数声明以后，console.log(test) 结果是函数代码
  				var c=a+b;
  	 			return c;
  	 		}；
  	 		test(2,3) -----  所以是调用也还是 函数代码 +（）

  
  ​	 	

+ 匿名函数+自调用函数，回调函数，函数设置默认参数，可变参数的函数（agruments），函数作为返回值；

  + 函数设置默认参数：

      function calc(x,y){
            x=x||0;
            y=y||0;
            return x+y;
        }

  + 函数作为返回值：结合闭包使用；

>    **函数没有返回值，却调用的时候用变量接收了，那么这个值的结果就是undefined**
>
>    **函数的实参和形参个数可以不相同，例如在使用arguments的时候**
>
>    **函数调用，如果某个参数没传，这个值就是undefined（形参中就算是 var声明了一下）**
>    					function apt(a,b){
>        						 console.log(a+"----"+b)
>   					  }
>     					apt(2)  // 2------undefined；  

    另外：
    var b=function(d,k,l){console.log("gsfg")};
    
    console.log(b.length)//返回形参的个数



补充：如何定义一个动态函数名的函数：

			var funcname=“fasdasd”；
		    window[funcname]=function(){}

  



8. 全局变量、局部变量，作用域链以及预解析

   + 全局变量和局部变量

     **首先明确一点，js中是没有块级作用域的**

     + 全局变量：变量是由var声明的--------可以在页面任何位置使用；

       > 是可以跨script标签使用的  --------（****）很厉害呀

     + 局部变量：在函数内部的定义的变量，+**形参也是局部变量**

       只能在函数内部被调用；函数调用结束之后 内存就释放；也是var调用的

       >**①函数内部用的不是局部变量的话  结束就不会被释放；**
       >
       >②函数内部的隐式全局变量，结束也不会释放；
       >
       >③ **函数内部调用的值；若本层中没有定义该局部变量，会去看看它的上一级 有没有同名的变量存在。如果有的话，会去调用这个；一次从里向外找；**-----作用域链
       >
       >

     + 隐式全局变量（不是用**var**声明的变量）

       在函数中声明的隐式全局变量----外部也是可以访问的；

       delete num-----可以删除隐式全局变量，但是不能删除全局变量；

       

   + 作用域链：

      在一个函数中使用一个变量，先在该函数中搜索这个变量，找到了则使用，找不到则继续向外面找这个 变量，找到则使用，一直找到全局作用域，找不到则是undefined；

     

   + 预解析：

     变量声明  var n 和 函数声明 function（）{console.log("...")}都会提前到当前作用域的最上方。所以函数声明在前在后 不影响调用执行

     > **script的标签内的也是一个作用域  只能提前到当前的script标签内部上方**
     >
     > **函数提升大于变量提升，变量提升会提升到除函数声明的后面

____

**这几个概念一般会糅杂在一起考选择题的！！！！！！！！！还会结合闭包和异步机制！！！！！！！！**

------------

* 



9. 对象：（对象的属性一般都是不带引号的，json数据的带引号）

   + 对象的声明方式（三种）

     + 通过字面量方式

     + 通过 new Object() 创建对象 ，随后obj.name 慢慢添加属性和方法；

     + 通过自定义构造函数创建对象

       > 先定义自定义构造函数  函数名用大写
       >
       >    function Person(name,age){
       >
       > ​		this.name=	name;
       >
       > ​		this.age=age;
       >
       > }
       >
       > var per1 = new Person("eason",15)

       ------------------------------------补充-----------------------------

       > instanceof  可以识别具体的引用类型，也就是构造函数名；
       >
       > ​           特殊情况：  var   a= String（“fad”）     -----instanceof有效
       >
       > ​                                 var  a= "faa"          -------------instanceof String   就是true
       >
       > ​	-----这就说明了 只有在调用方法的时候，基本类型才会转换成基本包装类型的

       > ​			

   + 访问对象的方式：点访问和[]访问；

     + 点访问  无论属性的键带不带双引号，在访问时候加不了双引号；（可以访问带双引号的键值）
     + [ ]访问  访问属性的时候，**不管属性的键带不带双引号，则访问的都要带双引号**（此时引号不能省），----在控制台上面测试的

   + 遍历对象   ： for (var key in json){}

10. 对象的部分概念介绍：

    静态对象（不需要实例化对象 直接调用） 和 实例对象（实例化以后 对实例进行调用）

    实例方法----必须通过new的方式创建的对象（实例对象）来调用方法；

    静态方法----直接通过大写的构造函数的名字调用的方法 如：String.fromCharCode()

    **如何判断对象的属性和方法是否存在**

    > 判断一个对象属性和方法是不是存在的
    >           if(obj[name]){...}
    >
    > 

11. Object对象属性及方法整理：

    + Object.keys(obj)---------键组成的字符串形式的数组（这个obj可以是数组，字符串，对象）

      ```
      let person = {name:"张三",age:25,address:"深圳",getName:function(){}}
      Object.keys(person) // ["name", "age", "address","getName"]
      
      let arr = [1,2,3,4,5,6]
      Object.keys(arr) // ["0", "1", "2", "3", "4", "5"]
      
      let str = "saasd字符串"
      Object.keys(str) // ["0", "1", "2", "3", "4", "5", "6", "7"]
      
      
      //常用技巧：
      let person = {name:"张三",age:25,address:"深圳",getName:function(){}}
      
      Object.keys(person).map((key)=>{
      
      　　person[key] // 获取到属性对应的值，做一些处理
      
      })
      ```

    

    + Object.values(obj) --------值组成的数组；

      

    + Object.assign(target, …sources)----**用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。**

      在source中有的属性  target中没有的 使用assign后 这些属性会加入到target中；

      在source中有的属性，target中有 但是属性值不一样，更新属性值到target中；

      

      用法一：复制对象

      ​					const obj = { a: 1 };

      ​					const copy = Object.assign({}, obj);

      ​					console.log(copy); *// { a: 1 }*

      

      

12.  string 和String对象+介绍包装类型：

    +  字符串的不可变性：

      var string="hello";  string[1]="w"   //这个是不可以操作的； --------记住就好 可能和语言底层设计有关；

    +  字符串也可以遍历

    + 普通的string是没有方法的 在调用方法的时候  **会去先包装成String对象  在调用方法，方法执行完毕，对象自动被销毁**



13. 基本包装类型理解：

    背景：**'hello' 和 new String('hello') 是有区别的**

    前者是字符串字面值，算基本类型，而后者是对象。用 typeof 运算符返回的值和instanceof也是不相等的：

    > typeof 'hello';  // 'string'                               "hello" instanceof String           //false
    > typeof new String('hello');  // 'object'         new String("hello") instanceof String   //true

​    上序的解释  还可以直接用 基本类型和 引用类型解释得通---------就是一个是基本类型，一个是对象

​	但是有的时候，基本类型也可以用 它对应的引用类型的方法，成了一个对象；这就需要包装类型来解释：

**当程序中有 基本类型用了对应引用类型的方法的语句， JS 在执行到这条语句的时候，内部将 'hello' 包装成了一个 String 对象，执行完后，再把这个对象丢弃了，（-----又丢弃了）**

所以会出现这个现象：

​		`									var num=10;
​	console.log(num.toString())
​	console.log(typeof num)---------还是number,方法执行完后，对象又被丢弃了  `

这种语法叫做 “装箱”，在其他面向对象语言里也有（如 C#）。不要认为 JS 帮你装箱了，你就可以在写代码的时候不分箱里箱外了**

**更完整的解释：**

基本包装类型： 本身是基本类型；**但在执行代码过程中，如果这个类型的变量调用了属性或者是方法
那么这种类型就不再是基本类型了，而实基本包装类型，**这个变量也不是普通的变量了，而实基本包装类型对象；

> 实际上，我们在读取一个基本类型的时候，后台就会创建一个基本包装类型的变量，从而让我们去执行这些方法，**而当方法执行完毕，对象自动被销毁**
>  			后台处理的流程：
>  						创建String类型的一个实例
>  						在实例上调用指定的方法
>  						销毁这个实例
>  			Boolean 和Number也是如此



14. Math对象的常用方法：

    Math.ceil(Math.random()*5) 生成  0-5的方法  ，也可以用parseInt（）

    

15. 数组和对象常用方法总结：---------------见文档哦





16. js的单线程环境、定时器运行。

参考文档：https://blog.csdn.net/Febby_/article/details/94763441

**在所有同步任务执行完之前，任何的异步任务是不会执行的**



   







   

